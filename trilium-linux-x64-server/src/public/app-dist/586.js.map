{"version":3,"file":"586.js","mappings":"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","sources":["webpack://trilium/./src/public/app/components/root_command_executor.js","webpack://trilium/./src/public/app/components/entrypoints.js","webpack://trilium/./src/public/app/components/note_context.js","webpack://trilium/./src/public/app/utils/mutex.js","webpack://trilium/./src/public/app/components/tab_manager.js","webpack://trilium/./src/public/app/components/mobile_screen_switcher.js","webpack://trilium/./src/public/app/components/main_tree_executors.js","webpack://trilium/./src/public/app/components/shortcut_component.js","webpack://trilium/./src/public/app/components/app_context.js","webpack://trilium/./src/public/app/components/component.js","webpack://trilium/./src/public/app/components/zoom.js","webpack://trilium/./src/public/app/entities/fattachment.js","webpack://trilium/./src/public/app/entities/fattribute.js","webpack://trilium/./src/public/app/entities/fbranch.js","webpack://trilium/./src/public/app/services/css_class_manager.js","webpack://trilium/./src/public/app/entities/fnote.js","webpack://trilium/./src/public/app/menus/context_menu.js","webpack://trilium/./src/public/app/menus/link_context_menu.js","webpack://trilium/./src/public/app/services/attribute_renderer.js","webpack://trilium/./src/public/app/services/bundle.js","webpack://trilium/./src/public/app/services/content_renderer.js","webpack://trilium/./src/public/app/services/date_notes.js","webpack://trilium/./src/public/app/services/dialog.js","webpack://trilium/./src/public/app/entities/fblob.js","webpack://trilium/./src/public/app/services/froca.js","webpack://trilium/./src/public/app/services/hoisted_note.js","webpack://trilium/./src/public/app/services/keyboard_actions.js","webpack://trilium/./src/public/app/services/library_loader.js","webpack://trilium/./src/public/app/services/link.js","webpack://trilium/./src/public/app/services/note_attribute_cache.js","webpack://trilium/./src/public/app/services/note_create.js","webpack://trilium/./src/public/app/services/note_tooltip.js","webpack://trilium/./src/public/app/services/open.js","webpack://trilium/./src/public/app/services/options.js","webpack://trilium/./src/public/app/services/promoted_attribute_definition_parser.js","webpack://trilium/./src/public/app/services/protected_session.js","webpack://trilium/./src/public/app/services/protected_session_holder.js","webpack://trilium/./src/public/app/services/render.js","webpack://trilium/./src/public/app/services/frontend_script_api.js","webpack://trilium/./src/public/app/services/script_context.js","webpack://trilium/./src/public/app/services/search.js","webpack://trilium/./src/public/app/services/validation_error.js","webpack://trilium/./src/public/app/services/server.js","webpack://trilium/./src/public/app/services/spaced_update.js","webpack://trilium/./src/public/app/services/toast.js","webpack://trilium/./src/public/app/services/tree.js","webpack://trilium/./src/public/app/services/load_results.js","webpack://trilium/./src/public/app/services/froca_updater.js","webpack://trilium/./src/public/app/services/ws.js","webpack://trilium/./src/public/app/widgets/basic_widget.js","webpack://trilium/./src/public/app/widgets/note_context_aware_widget.js","webpack://trilium/./src/public/app/widgets/right_panel_widget.js"],"sourcesContent":["import Component from \"./component.js\";\nimport appContext from \"./app_context.js\";\nimport dateNoteService from \"../services/date_notes.js\";\nimport treeService from \"../services/tree.js\";\nimport openService from \"../services/open.js\";\nimport protectedSessionService from \"../services/protected_session.js\";\nimport options from \"../services/options.js\";\nimport froca from \"../services/froca.js\";\nimport utils from \"../services/utils.js\";\n\nexport default class RootCommandExecutor extends Component {\n    editReadOnlyNoteCommand() {\n        const noteContext = appContext.tabManager.getActiveContext();\n        noteContext.viewScope.readOnlyTemporarilyDisabled = true;\n\n        appContext.triggerEvent(\"readOnlyTemporarilyDisabled\", { noteContext });\n    }\n\n    async showSQLConsoleCommand() {\n        const sqlConsoleNote = await dateNoteService.createSqlConsole();\n\n        const noteContext = await appContext.tabManager.openTabWithNoteWithHoisting(sqlConsoleNote.noteId, { activate: true });\n\n        appContext.triggerEvent('focusOnDetail', {ntxId: noteContext.ntxId});\n    }\n\n    async searchNotesCommand({searchString, ancestorNoteId}) {\n        const searchNote = await dateNoteService.createSearchNote({searchString, ancestorNoteId});\n\n        // force immediate search\n        await froca.loadSearchNote(searchNote.noteId);\n\n        const noteContext = await appContext.tabManager.openTabWithNoteWithHoisting(searchNote.noteId, {\n            activate: true\n        });\n\n        appContext.triggerCommand('focusOnSearchDefinition', {ntxId: noteContext.ntxId});\n    }\n\n    async searchInSubtreeCommand({notePath}) {\n        const noteId = treeService.getNoteIdFromUrl(notePath);\n\n        this.searchNotesCommand({ancestorNoteId: noteId});\n    }\n\n    openNoteExternallyCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n        const mime = appContext.tabManager.getActiveContextNoteMime();\n        if (noteId) {\n            openService.openNoteExternally(noteId, mime);\n        }\n    }\n\n    openNoteCustomCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n        const mime = appContext.tabManager.getActiveContextNoteMime();\n        if (noteId) {\n            openService.openNoteCustom(noteId, mime);\n        }\n    }\n\n    enterProtectedSessionCommand() {\n        protectedSessionService.enterProtectedSession();\n    }\n\n    leaveProtectedSessionCommand() {\n        protectedSessionService.leaveProtectedSession();\n    }\n\n    hideLeftPaneCommand() {\n        options.save(`leftPaneVisible`, \"false\");\n    }\n\n    showLeftPaneCommand() {\n        options.save(`leftPaneVisible`, \"true\");\n    }\n\n    toggleLeftPaneCommand() {\n        options.toggle('leftPaneVisible');\n    }\n\n    async showBackendLogCommand() {\n        await appContext.tabManager.openTabWithNoteWithHoisting('_backendLog', { activate: true });\n    }\n\n    async showLaunchBarSubtreeCommand() {\n        await this.showAndHoistSubtree('_lbRoot');\n    }\n\n    async showShareSubtreeCommand() {\n        await this.showAndHoistSubtree('_share');\n    }\n\n    async showHiddenSubtreeCommand() {\n        await this.showAndHoistSubtree('_hidden');\n    }\n\n    async showOptionsCommand({section}) {\n        await appContext.tabManager.openContextWithNote(section || '_options', {\n            activate: true,\n            hoistedNoteId: '_options'\n        });\n    }\n\n    async showSQLConsoleHistoryCommand() {\n        await this.showAndHoistSubtree('_sqlConsole');\n    }\n\n    async showSearchHistoryCommand() {\n        await this.showAndHoistSubtree('_search');\n    }\n\n    async showAndHoistSubtree(subtreeNoteId) {\n        await appContext.tabManager.openContextWithNote(subtreeNoteId, {\n            activate: true,\n            hoistedNoteId: subtreeNoteId\n        });\n    }\n\n    async showNoteSourceCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'source'\n                }\n            });\n        }\n    }\n\n    async showAttachmentsCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'attachments'\n                }\n            });\n        }\n    }\n\n    async showAttachmentDetailCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'attachments'\n                }\n            });\n        }\n    }\n\n    toggleTrayCommand() {\n        if (!utils.isElectron()) return;\n        const {BrowserWindow} = utils.dynamicRequire('@electron/remote');\n        const windows = BrowserWindow.getAllWindows();\n        const isVisible = windows.every(w => w.isVisible());\n        const action = isVisible ? \"hide\" : \"show\"\n        for (const window of windows) window[action]();\n    }\n\n    firstTabCommand()   { this.#goToTab(1); }\n    secondTabCommand()  { this.#goToTab(2); }\n    thirdTabCommand()   { this.#goToTab(3); }\n    fourthTabCommand()  { this.#goToTab(4); }\n    fifthTabCommand()   { this.#goToTab(5); }\n    sixthTabCommand()   { this.#goToTab(6); }\n    seventhTabCommand() { this.#goToTab(7); }\n    eigthTabCommand()   { this.#goToTab(8); }\n    ninthTabCommand()   { this.#goToTab(9); }\n    lastTabCommand()    { this.#goToTab(Number.POSITIVE_INFINITY); }\n\n    #goToTab(tabNumber) {\n        const mainNoteContexts = appContext.tabManager.getMainNoteContexts();\n\n        const index = tabNumber === Number.POSITIVE_INFINITY ? mainNoteContexts.length - 1 : tabNumber - 1;\n        const tab = mainNoteContexts[index];\n\n        if (tab) {\n            appContext.tabManager.activateNoteContext(tab.ntxId);\n        }\n    }\n}\n","import utils from \"../services/utils.js\";\nimport dateNoteService from \"../services/date_notes.js\";\nimport protectedSessionHolder from '../services/protected_session_holder.js';\nimport server from \"../services/server.js\";\nimport appContext from \"./app_context.js\";\nimport Component from \"./component.js\";\nimport toastService from \"../services/toast.js\";\nimport ws from \"../services/ws.js\";\nimport bundleService from \"../services/bundle.js\";\nimport froca from \"../services/froca.js\";\nimport linkService from \"../services/link.js\";\n\nexport default class Entrypoints extends Component {\n    constructor() {\n        super();\n\n        if (jQuery.hotkeys) {\n            // hot keys are active also inside inputs and content editables\n            jQuery.hotkeys.options.filterInputAcceptingElements = false;\n            jQuery.hotkeys.options.filterContentEditable = false;\n            jQuery.hotkeys.options.filterTextInputs = false;\n        }\n    }\n\n    openDevToolsCommand() {\n        if (utils.isElectron()) {\n            utils.dynamicRequire('@electron/remote').getCurrentWindow().toggleDevTools();\n        }\n    }\n\n    async createNoteIntoInboxCommand() {\n        const inboxNote = await dateNoteService.getInboxNote();\n\n        const {note} = await server.post(`notes/${inboxNote.noteId}/children?target=into`, {\n            content: '',\n            type: 'text',\n            isProtected: inboxNote.isProtected && protectedSessionHolder.isProtectedSessionAvailable()\n        });\n\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.openTabWithNoteWithHoisting(note.noteId, {activate: true});\n\n        appContext.triggerEvent('focusAndSelectTitle', {isNewNote: true});\n    }\n\n    async toggleNoteHoistingCommand({noteId = appContext.tabManager.getActiveContextNoteId()}) {\n        const noteToHoist = await froca.getNote(noteId);\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (noteToHoist.noteId === activeNoteContext.hoistedNoteId) {\n            await activeNoteContext.unhoist();\n        }\n        else if (noteToHoist.type !== 'search') {\n            await activeNoteContext.setHoistedNoteId(noteId);\n        }\n    }\n\n    async hoistNoteCommand({noteId}) {\n        const noteContext = appContext.tabManager.getActiveContext();\n\n        if (noteContext.hoistedNoteId !== noteId) {\n            await noteContext.setHoistedNoteId(noteId);\n        }\n    }\n\n    async unhoistCommand() {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (activeNoteContext) {\n            activeNoteContext.unhoist();\n        }\n    }\n\n    copyWithoutFormattingCommand() {\n        utils.copySelectionToClipboard();\n    }\n\n    toggleFullscreenCommand() {\n        if (utils.isElectron()) {\n            const win = utils.dynamicRequire('@electron/remote').getCurrentWindow();\n\n            if (win.isFullScreenable()) {\n                win.setFullScreen(!win.isFullScreen());\n            }\n        } // outside of electron this is handled by the browser\n    }\n\n    reloadFrontendAppCommand() {\n        utils.reloadFrontendApp();\n    }\n\n    logoutCommand() {\n        const $logoutForm = $('<form action=\"logout\" method=\"POST\">')\n            .append($(`<input type='_hidden' name=\"_csrf\" value=\"${glob.csrfToken}\"/>`));\n\n        $(\"body\").append($logoutForm);\n        $logoutForm.trigger('submit');\n    }\n\n    backInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('@electron/remote').getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex - 1);\n        }\n        else {\n            window.history.back();\n        }\n    }\n\n    forwardInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('@electron/remote').getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex + 1);\n        }\n        else {\n            window.history.forward();\n        }\n    }\n\n    async switchToDesktopVersionCommand() {\n        utils.setCookie('trilium-device', 'desktop');\n\n        utils.reloadFrontendApp(\"正在切换到桌面版\");\n    }\n\n    async switchToMobileVersionCommand() {\n        utils.setCookie('trilium-device', 'mobile');\n\n        utils.reloadFrontendApp(\"正在切换到移动版\");\n    }\n\n    async openInWindowCommand({notePath, hoistedNoteId, viewScope}) {\n        const extraWindowHash = linkService.calculateHash({notePath, hoistedNoteId, viewScope});\n\n        if (utils.isElectron()) {\n            const {ipcRenderer} = utils.dynamicRequire('electron');\n\n            ipcRenderer.send('create-extra-window', { extraWindowHash });\n        }\n        else {\n            const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?extraWindow=1${extraWindowHash}`;\n\n            window.open(url, '', 'width=1000,height=800');\n        }\n    }\n\n    async openNewWindowCommand() {\n        this.openInWindowCommand({notePath: '', hoistedNoteId: 'root'});\n    }\n\n    async runActiveNoteCommand() {\n        const {ntxId, note} = appContext.tabManager.getActiveContext();\n\n        // ctrl+enter is also used elsewhere, so make sure we're running only when appropriate\n        if (!note || note.type !== 'code') {\n            return;\n        }\n\n        // TODO: use note.executeScript()\n        if (note.mime.endsWith(\"env=frontend\")) {\n            await bundleService.getAndExecuteBundle(note.noteId);\n        } else if (note.mime.endsWith(\"env=backend\")) {\n            await server.post(`script/run/${note.noteId}`);\n        } else if (note.mime === 'text/x-sqlite;schema=trilium') {\n            const resp = await server.post(`sql/execute/${note.noteId}`);\n\n            if (!resp.success) {\n                toastService.showError(`Error occurred while executing SQL query: ${resp.error}`);\n            }\n\n            await appContext.triggerEvent('sqlQueryResults', {ntxId: ntxId, results: resp.results});\n        }\n\n        toastService.showMessage(\"笔记已执行\");\n    }\n\n    hideAllPopups() {\n        if (utils.isDesktop()) {\n            $(\".aa-input\").autocomplete(\"close\");\n        }\n    }\n\n    noteSwitchedEvent() {\n        this.hideAllPopups();\n    }\n\n    activeContextChangedEvent() {\n        this.hideAllPopups();\n    }\n\n    async forceSaveRevisionCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n\n        await server.post(`notes/${noteId}/revision`);\n\n        toastService.showMessage(\"笔记历史已创建\");\n    }\n}\n","import protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport server from \"../services/server.js\";\nimport utils from \"../services/utils.js\";\nimport appContext from \"./app_context.js\";\nimport treeService from \"../services/tree.js\";\nimport Component from \"./component.js\";\nimport froca from \"../services/froca.js\";\nimport hoistedNoteService from \"../services/hoisted_note.js\";\nimport options from \"../services/options.js\";\n\nclass NoteContext extends Component {\n    constructor(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) {\n        super();\n\n        this.ntxId = ntxId || this.constructor.generateNtxId();\n        this.hoistedNoteId = hoistedNoteId;\n        this.mainNtxId = mainNtxId;\n\n        this.resetViewScope();\n    }\n\n    static generateNtxId() {\n        return utils.randomString(6);\n    }\n\n    setEmpty() {\n        this.notePath = null;\n        this.noteId = null;\n        this.parentNoteId = null;\n        // hoisted note is kept intentionally\n\n        this.triggerEvent('noteSwitched', {\n            noteContext: this,\n            notePath: this.notePath\n        });\n\n        this.resetViewScope();\n    }\n\n    isEmpty() {\n        return !this.noteId;\n    }\n\n    async setNote(inputNotePath, opts = {}) {\n        opts.triggerSwitchEvent = opts.triggerSwitchEvent !== undefined ? opts.triggerSwitchEvent : true;\n        opts.viewScope = opts.viewScope || {};\n        opts.viewScope.viewMode = opts.viewScope.viewMode || \"default\";\n\n        const resolvedNotePath = await this.getResolvedNotePath(inputNotePath);\n\n        if (!resolvedNotePath) {\n            return;\n        }\n\n        if (this.notePath === resolvedNotePath && utils.areObjectsEqual(this.viewScope, opts.viewScope)) {\n            return;\n        }\n\n        await this.triggerEvent('beforeNoteSwitch', {noteContext: this});\n\n        utils.closeActiveDialog();\n\n        this.notePath = resolvedNotePath;\n        this.viewScope = opts.viewScope;\n        ({noteId: this.noteId, parentNoteId: this.parentNoteId} = treeService.getNoteIdAndParentIdFromUrl(resolvedNotePath));\n\n        this.saveToRecentNotes(resolvedNotePath);\n\n        protectedSessionHolder.touchProtectedSessionIfNecessary(this.note);\n\n        if (opts.triggerSwitchEvent) {\n            await this.triggerEvent('noteSwitched', {\n                noteContext: this,\n                notePath: this.notePath\n            });\n        }\n\n        await this.setHoistedNoteIfNeeded();\n\n        if (utils.isMobile()) {\n            this.triggerCommand('setActiveScreen', {screen: 'detail'});\n        }\n    }\n\n    async setHoistedNoteIfNeeded() {\n        if (this.hoistedNoteId === 'root'\n            && this.notePath.startsWith(\"root/_hidden\")\n            && !this.note.isLabelTruthy(\"keepCurrentHoisting\")\n        ) {\n            // hidden subtree displays only when hoisted, so it doesn't make sense to keep root as hoisted note\n\n            let hoistedNoteId = '_hidden';\n\n            if (this.note.isLaunchBarConfig()) {\n                hoistedNoteId = '_lbRoot';\n            } else if (this.note.isOptions()) {\n                hoistedNoteId = '_options';\n            }\n\n            await this.setHoistedNoteId(hoistedNoteId);\n        }\n    }\n\n    getSubContexts() {\n        return appContext.tabManager.noteContexts.filter(nc => nc.ntxId === this.ntxId || nc.mainNtxId === this.ntxId);\n    }\n\n    /**\n     * A main context represents a tab and also the first split. Further splits are the children contexts of the main context.\n     * Imagine you have a tab with 3 splits, each showing notes A, B, C (in this order).\n     * In such a scenario, A context is the main context (also representing the tab as a whole), and B, C are the children\n     * of context A.\n     *\n     * @returns {boolean} true if the context is main (= tab)\n     */\n    isMainContext() {\n        // if null, then this is a main context\n        return !this.mainNtxId;\n    }\n\n    /**\n     * See docs for isMainContext() for better explanation.\n     *\n     * @returns {NoteContext}\n     */\n    getMainContext() {\n        if (this.mainNtxId) {\n            try {\n                return appContext.tabManager.getNoteContextById(this.mainNtxId);\n            }\n            catch (e) {\n                this.mainNtxId = null;\n                return this;\n            }\n        }\n        else {\n            return this;\n        }\n    }\n\n    saveToRecentNotes(resolvedNotePath) {\n        setTimeout(async () => {\n            // we include the note in the recent list only if the user stayed on the note at least 5 seconds\n            if (resolvedNotePath && resolvedNotePath === this.notePath) {\n                await server.post('recent-notes', {\n                    noteId: this.note.noteId,\n                    notePath: this.notePath\n                });\n            }\n        }, 5000);\n    }\n\n    async getResolvedNotePath(inputNotePath) {\n        const resolvedNotePath = await treeService.resolveNotePath(inputNotePath, this.hoistedNoteId);\n\n        if (!resolvedNotePath) {\n            logError(`Cannot resolve note path ${inputNotePath}`);\n            return;\n        }\n\n        if (await hoistedNoteService.checkNoteAccess(resolvedNotePath, this) === false) {\n            return; // note is outside of hoisted subtree and user chose not to unhoist\n        }\n\n        return resolvedNotePath;\n    }\n\n    /** @returns {FNote} */\n    get note() {\n        if (!this.noteId || !(this.noteId in froca.notes)) {\n            return null;\n        }\n\n        return froca.notes[this.noteId];\n    }\n\n    /** @returns {string[]} */\n    get notePathArray() {\n        return this.notePath ? this.notePath.split('/') : [];\n    }\n\n    isActive() {\n        return appContext.tabManager.activeNtxId === this.ntxId;\n    }\n\n    getPojoState() {\n        if (this.hoistedNoteId !== 'root') {\n            // keeping empty hoisted tab is esp. important for mobile (e.g. opened launcher config)\n\n            if (!this.notePath && this.getSubContexts().length === 0) {\n                return null;\n            }\n        }\n\n        return {\n            ntxId: this.ntxId,\n            mainNtxId: this.mainNtxId,\n            notePath: this.notePath,\n            hoistedNoteId: this.hoistedNoteId,\n            active: this.isActive(),\n            viewScope: this.viewScope\n        }\n    }\n\n    async unhoist() {\n        await this.setHoistedNoteId('root');\n    }\n\n    async setHoistedNoteId(noteIdToHoist) {\n        if (this.hoistedNoteId === noteIdToHoist) {\n            return;\n        }\n\n        this.hoistedNoteId = noteIdToHoist;\n\n        if (!this.notePathArray?.includes(noteIdToHoist) && !utils.isMobile()) {\n            await this.setNote(noteIdToHoist);\n        }\n\n        await this.triggerEvent('hoistedNoteChanged', {\n            noteId: noteIdToHoist,\n            ntxId: this.ntxId\n        });\n    }\n\n    /** @returns {Promise<boolean>} */\n    async isReadOnly() {\n        if (this.viewScope.readOnlyTemporarilyDisabled) {\n            return false;\n        }\n\n        // \"readOnly\" is a state valid only for text/code notes\n        if (!this.note || (this.note.type !== 'text' && this.note.type !== 'code')) {\n            return false;\n        }\n\n        if (this.note.isLabelTruthy('readOnly')) {\n            return true;\n        }\n\n        if (this.viewScope.viewMode === 'source') {\n            return true;\n        }\n\n        const blob = await this.note.getBlob();\n\n        const sizeLimit = this.note.type === 'text'\n            ? options.getInt('autoReadonlySizeText')\n            : options.getInt('autoReadonlySizeCode');\n\n        return blob.contentLength > sizeLimit\n            && !this.note.isLabelTruthy('autoReadOnlyDisabled');\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteReloaded(this.noteId)) {\n            const noteRow = loadResults.getEntityRow('notes', this.noteId);\n\n            if (noteRow.isDeleted) {\n                this.noteId = null;\n                this.notePath = null;\n\n                this.triggerEvent('noteSwitched', {\n                    noteContext: this,\n                    notePath: this.notePath\n                });\n            }\n        }\n    }\n\n    hasNoteList() {\n        return this.note\n            && this.viewScope.viewMode === 'default'\n            && this.note.hasChildren()\n            && ['book', 'text', 'code'].includes(this.note.type)\n            && this.note.mime !== 'text/x-sqlite;schema=trilium'\n            && !this.note.isLabelTruthy('hideChildrenOverview');\n    }\n\n    async getTextEditor(callback) {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithTextEditor', {\n            callback,\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getCodeEditor() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithCodeEditor', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getContentElement() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithContentElement', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getTypeWidget() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithTypeWidget', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    timeout(promise) {\n        return Promise.race([\n            promise,\n            new Promise(res => setTimeout(() => res(null), 200))\n        ]);\n    }\n\n    resetViewScope() {\n        // view scope contains data specific to one note context and one \"view\".\n        // it is used to e.g., make read-only note temporarily editable or to hide TOC\n        // this is reset after navigating to a different note\n        this.viewScope = {};\n    }\n\n    async getNavigationTitle() {\n        if (!this.note) {\n            return null;\n        }\n\n        const { note, viewScope } = this;\n\n        let title = viewScope.viewMode === 'default'\n            ? note.title\n            : `${note.title}: ${viewScope.viewMode}`;\n\n        if (viewScope.attachmentId) {\n            // assuming the attachment has been already loaded\n            const attachment = await note.getAttachmentById(viewScope.attachmentId);\n\n            if (attachment) {\n                title += `: ${attachment.title}`;\n            }\n        }\n\n        return title;\n    }\n}\n\nexport default NoteContext;\n","export default class Mutex {\n    constructor() {\n        this.current = Promise.resolve();\n    }\n\n    /** @returns {Promise} */\n    lock() {\n        let resolveFun;\n        const subPromise = new Promise(resolve => resolveFun = () => resolve());\n        // Caller gets a promise that resolves when the current outstanding lock resolves\n        const newPromise = this.current.then(() => resolveFun);\n        // Don't allow the next request until the new promise is done\n        this.current = subPromise;\n        // Return the new promise\n        return newPromise;\n    };\n\n    async runExclusively(cb) {\n        const unlock = await this.lock();\n\n        try {\n            return await cb();\n        }\n        finally {\n            unlock();\n        }\n    }\n}\n","import Component from \"./component.js\";\nimport SpacedUpdate from \"../services/spaced_update.js\";\nimport server from \"../services/server.js\";\nimport options from \"../services/options.js\";\nimport froca from \"../services/froca.js\";\nimport treeService from \"../services/tree.js\";\nimport utils from \"../services/utils.js\";\nimport NoteContext from \"./note_context.js\";\nimport appContext from \"./app_context.js\";\nimport Mutex from \"../utils/mutex.js\";\nimport linkService from \"../services/link.js\";\n\nexport default class TabManager extends Component {\n    constructor() {\n        super();\n\n        /** @property {NoteContext[]} */\n        this.children = [];\n        this.mutex = new Mutex();\n\n        this.activeNtxId = null;\n\n        // elements are arrays of {contexts, position}, storing note contexts for each tab (one main context + subcontexts [splits]), and the original position of the tab\n        this.recentlyClosedTabs = [];\n\n        this.tabsUpdate = new SpacedUpdate(async () => {\n            if (!appContext.isMainWindow) {\n                return;\n            }\n\n            const openNoteContexts = this.noteContexts\n                .map(nc => nc.getPojoState())\n                .filter(t => !!t);\n\n            await server.put('options', {\n                openNoteContexts: JSON.stringify(openNoteContexts)\n            });\n        });\n\n        appContext.addBeforeUnloadListener(this);\n    }\n\n    /** @returns {NoteContext[]} */\n    get noteContexts() {\n        return this.children;\n    }\n\n    /** @type {NoteContext[]} */\n    get mainNoteContexts() {\n        return this.noteContexts.filter(nc => !nc.mainNtxId)\n    }\n\n    async loadTabs() {\n        try {\n            const noteContextsToOpen = (appContext.isMainWindow && options.getJson('openNoteContexts')) || [];\n\n            // preload all notes at once\n            await froca.getNotes([\n                    ...noteContextsToOpen.flatMap(tab =>\n                        [ treeService.getNoteIdFromUrl(tab.notePath), tab.hoistedNoteId]\n                    ),\n            ], true);\n\n            const filteredNoteContexts = noteContextsToOpen.filter(openTab => {\n                if (utils.isMobile()) { // mobile frontend doesn't have tabs so show only the active tab\n                    return !!openTab.active;\n                }\n\n                const noteId = treeService.getNoteIdFromUrl(openTab.notePath);\n                if (!(noteId in froca.notes)) {\n                    // note doesn't exist so don't try to open tab for it\n                    return false;\n                }\n\n                if (!(openTab.hoistedNoteId in froca.notes)) {\n                    openTab.hoistedNoteId = 'root';\n                }\n\n                return true;\n            });\n\n            // resolve before opened tabs can change this\n            const parsedFromUrl = linkService.parseNavigationStateFromUrl(window.location.href);\n\n            if (filteredNoteContexts.length === 0) {\n                parsedFromUrl.ntxId = parsedFromUrl.ntxId || NoteContext.generateNtxId(); // generate already here, so that we later know which one to activate\n\n                filteredNoteContexts.push({\n                    notePath: parsedFromUrl.notePath || 'root',\n                    ntxId: parsedFromUrl.ntxId,\n                    active: true,\n                    hoistedNoteId: parsedFromUrl.hoistedNoteId || 'root',\n                    viewScope: parsedFromUrl.viewScope || {}\n                });\n            } else if (!filteredNoteContexts.find(tab => tab.active)) {\n                filteredNoteContexts[0].active = true;\n            }\n\n            await this.tabsUpdate.allowUpdateWithoutChange(async () => {\n                for (const tab of filteredNoteContexts) {\n                    await this.openContextWithNote(tab.notePath, {\n                        activate: tab.active,\n                        ntxId: tab.ntxId,\n                        mainNtxId: tab.mainNtxId,\n                        hoistedNoteId: tab.hoistedNoteId,\n                        viewScope: tab.viewScope\n                    });\n                }\n            });\n\n            // if there's a notePath in the URL, make sure it's open and active\n            // (useful, for e.g., opening clipped notes from clipper or opening link in an extra window)\n            if (parsedFromUrl.notePath) {\n                await appContext.tabManager.switchToNoteContext(\n                    parsedFromUrl.ntxId,\n                    parsedFromUrl.notePath,\n                    parsedFromUrl.viewScope,\n                    parsedFromUrl.hoistedNoteId\n                );\n            } else if (parsedFromUrl.searchString) {\n                await appContext.triggerCommand('searchNotes', {\n                    searchString: parsedFromUrl.searchString\n                });\n            }\n        }\n        catch (e) {\n            logError(`Loading note contexts '${options.get('openNoteContexts')}' failed: ${e.message} ${e.stack}`);\n\n            // try to recover\n            await this.openEmptyTab();\n        }\n    }\n\n    noteSwitchedEvent({noteContext}) {\n        if (noteContext.isActive()) {\n            this.setCurrentNavigationStateToHash();\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    setCurrentNavigationStateToHash() {\n        const calculatedHash = this.calculateHash();\n\n        // update if it's the first history entry or there has been a change\n        if (window.history.length === 0 || calculatedHash !== window.location?.hash) {\n            // using pushState instead of directly modifying document.location because it does not trigger hashchange\n            window.history.pushState(null, \"\", calculatedHash);\n        }\n\n        const activeNoteContext = this.getActiveContext();\n        this.updateDocumentTitle(activeNoteContext);\n\n        this.triggerEvent('activeNoteChanged'); // trigger this even in on popstate event\n    }\n\n    calculateHash() {\n        const activeNoteContext = this.getActiveContext();\n        if (!activeNoteContext) {\n            return \"\";\n        }\n\n        return linkService.calculateHash({\n            notePath: activeNoteContext.notePath,\n            ntxId: activeNoteContext.ntxId,\n            hoistedNoteId: activeNoteContext.hoistedNoteId,\n            viewScope: activeNoteContext.viewScope\n        });\n    }\n\n    /** @returns {NoteContext[]} */\n    getNoteContexts() {\n        return this.noteContexts;\n    }\n\n    /**\n     * Main context is essentially a tab (children are splits), so this returns tabs.\n     * @returns {NoteContext[]}\n     */\n    getMainNoteContexts() {\n        return this.noteContexts.filter(nc => nc.isMainContext());\n    }\n\n    /** @returns {NoteContext} */\n    getNoteContextById(ntxId) {\n        const noteContext = this.noteContexts.find(nc => nc.ntxId === ntxId);\n\n        if (!noteContext) {\n            throw new Error(`找不到 noteContext id='${ntxId}'`);\n        }\n\n        return noteContext;\n    }\n\n    /**\n     * Get active context which represents the visible split with focus. Active context can, but doesn't have to be \"main\".\n     *\n     * @returns {NoteContext}\n     */\n    getActiveContext() {\n        return this.activeNtxId\n            ? this.getNoteContextById(this.activeNtxId)\n            : null;\n    }\n\n    /**\n     * Get active main context which corresponds to the active tab.\n     *\n     * @returns {NoteContext}\n     */\n    getActiveMainContext() {\n        return this.activeNtxId\n            ? this.getNoteContextById(this.activeNtxId).getMainContext()\n            : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNotePath() {\n        const activeContext = this.getActiveContext();\n        return activeContext ? activeContext.notePath : null;\n    }\n\n    /** @returns {FNote} */\n    getActiveContextNote() {\n        const activeContext = this.getActiveContext();\n        return activeContext ? activeContext.note : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNoteId() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.noteId : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNoteType() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.type : null;\n    }\n    /** @returns {string|null} */\n    getActiveContextNoteMime() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.mime : null;\n    }\n\n    async switchToNoteContext(ntxId, notePath, viewScope = {}, hoistedNoteId = null) {\n        const noteContext = this.noteContexts.find(nc => nc.ntxId === ntxId)\n            || await this.openEmptyTab();\n\n        await this.activateNoteContext(noteContext.ntxId);\n\n        if (hoistedNoteId) {\n            await noteContext.setHoistedNoteId(hoistedNoteId);\n        }\n\n        if (notePath) {\n            await noteContext.setNote(notePath, { viewScope });\n        }\n    }\n\n    async openAndActivateEmptyTab() {\n        const noteContext = await this.openEmptyTab();\n\n        await this.activateNoteContext(noteContext.ntxId);\n\n        await noteContext.setEmpty();\n    }\n\n    async openEmptyTab(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) {\n        const noteContext = new NoteContext(ntxId, hoistedNoteId, mainNtxId);\n\n        let existingNoteContext;\n\n        if (utils.isMobile()) {\n            // kind of hacky way to enforce a single tab on mobile interface - all requests to create a new one\n            // are forced to reuse the existing ab instead\n            existingNoteContext = this.getActiveContext();\n        } else {\n            existingNoteContext = this.children.find(nc => nc.ntxId === noteContext.ntxId);\n        }\n\n        if (existingNoteContext) {\n            await existingNoteContext.setHoistedNoteId(hoistedNoteId);\n\n            return existingNoteContext;\n        }\n\n        this.child(noteContext);\n\n        await this.triggerEvent('newNoteContextCreated', {noteContext});\n\n        return noteContext;\n    }\n\n    async openInNewTab(targetNoteId, hoistedNoteId = null) {\n        const noteContext = await this.openEmptyTab(null, hoistedNoteId || this.getActiveContext().hoistedNoteId);\n\n        await noteContext.setNote(targetNoteId);\n    }\n\n    async openInSameTab(targetNoteId, hoistedNoteId = null) {\n        const activeContext = this.getActiveContext();\n        await activeContext.setHoistedNoteId(hoistedNoteId || activeContext.hoistedNoteId);\n        await activeContext.setNote(targetNoteId);\n    }\n\n    /**\n     * If the requested notePath is within current note hoisting scope then keep the note hoisting also for the new tab.\n     */\n    async openTabWithNoteWithHoisting(notePath, opts = {}) {\n        const noteContext = this.getActiveContext();\n        let hoistedNoteId = 'root';\n\n        if (noteContext) {\n            const resolvedNotePath = await treeService.resolveNotePath(notePath, noteContext.hoistedNoteId);\n\n            if (resolvedNotePath.includes(noteContext.hoistedNoteId) || resolvedNotePath.includes('_hidden')) {\n                hoistedNoteId = noteContext.hoistedNoteId;\n            }\n        }\n\n        opts.hoistedNoteId = hoistedNoteId;\n\n        return this.openContextWithNote(notePath, opts);\n    }\n\n    async openContextWithNote(notePath, opts = {}) {\n        const activate = !!opts.activate;\n        const ntxId = opts.ntxId || null;\n        const mainNtxId = opts.mainNtxId || null;\n        const hoistedNoteId = opts.hoistedNoteId || 'root';\n        const viewScope = opts.viewScope || { viewMode: \"default\" };\n\n        const noteContext = await this.openEmptyTab(ntxId, hoistedNoteId, mainNtxId);\n\n        if (notePath) {\n            await noteContext.setNote(notePath, {\n                // if activate is false, then send normal noteSwitched event\n                triggerSwitchEvent: !activate,\n                viewScope: viewScope\n            });\n        }\n\n        if (activate) {\n            this.activateNoteContext(noteContext.ntxId, false);\n\n            await this.triggerEvent('noteSwitchedAndActivated', {\n                noteContext,\n                notePath: noteContext.notePath // resolved note path\n            });\n        }\n\n        return noteContext;\n    }\n\n    async activateOrOpenNote(noteId) {\n        for (const noteContext of this.getNoteContexts()) {\n            if (noteContext.note && noteContext.note.noteId === noteId) {\n                this.activateNoteContext(noteContext.ntxId);\n\n                return;\n            }\n        }\n\n        // if no tab with this note has been found we'll create new tab\n\n        await this.openContextWithNote(noteId, { activate: true });\n    }\n\n    async activateNoteContext(ntxId, triggerEvent = true) {\n        if (ntxId === this.activeNtxId) {\n            return;\n        }\n\n        this.activeNtxId = ntxId;\n\n        if (triggerEvent) {\n            await this.triggerEvent('activeContextChanged', {\n                noteContext: this.getNoteContextById(ntxId)\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n\n        this.setCurrentNavigationStateToHash();\n    }\n\n    /**\n     * @param ntxId\n     * @returns {Promise<boolean>} true if note context has been removed, false otherwise\n     */\n    async removeNoteContext(ntxId) {\n        // removing note context is an async process which can take some time, if users presses CTRL-W quickly, two\n        // close events could interleave which would then lead to attempting to activate already removed context.\n        return await this.mutex.runExclusively(async () => {\n            let noteContextToRemove;\n\n            try {\n                noteContextToRemove = this.getNoteContextById(ntxId);\n            }\n            catch {\n                // note context not found\n                return false;\n            }\n\n            if (noteContextToRemove.isMainContext()) {\n                const mainNoteContexts = this.getNoteContexts().filter(nc => nc.isMainContext());\n\n                if (mainNoteContexts.length === 1) {\n                    if (noteContextToRemove.isEmpty()) {\n                        // this is already the empty note context, no point in closing it and replacing with another\n                        // empty tab\n                        return false;\n                    }\n\n                    await this.openEmptyTab();\n                }\n            }\n\n            // close dangling autocompletes after closing the tab\n            $(\".aa-input\").autocomplete(\"close\");\n\n            const noteContextsToRemove = noteContextToRemove.getSubContexts();\n            const ntxIdsToRemove = noteContextsToRemove.map(nc => nc.ntxId);\n\n            await this.triggerEvent('beforeNoteContextRemove', { ntxIds: ntxIdsToRemove });\n\n            if (!noteContextToRemove.isMainContext()) {\n                const siblings = noteContextToRemove.getMainContext().getSubContexts();\n                const idx = siblings.findIndex(nc => nc.ntxId === noteContextToRemove.ntxId);\n                const contextToActivateIdx = idx === siblings.length - 1 ? idx - 1 : idx + 1;\n                const contextToActivate = siblings[contextToActivateIdx];\n\n                await this.activateNoteContext(contextToActivate.ntxId);\n            }\n            else if (this.mainNoteContexts.length <= 1) {\n                await this.openAndActivateEmptyTab();\n            }\n            else if (ntxIdsToRemove.includes(this.activeNtxId)) {\n                const idx = this.mainNoteContexts.findIndex(nc => nc.ntxId === noteContextToRemove.ntxId);\n\n                if (idx === this.mainNoteContexts.length - 1) {\n                    await this.activatePreviousTabCommand();\n                }\n                else {\n                    await this.activateNextTabCommand();\n                }\n            }\n\n            this.removeNoteContexts(noteContextsToRemove);\n\n            return true;\n        });\n    }\n\n    removeNoteContexts(noteContextsToRemove) {\n        const ntxIdsToRemove = noteContextsToRemove.map(nc => nc.ntxId);\n\n        const position = this.noteContexts.findIndex(nc => ntxIdsToRemove.includes(nc.ntxId));\n\n        this.children = this.children.filter(nc => !ntxIdsToRemove.includes(nc.ntxId));\n\n        this.addToRecentlyClosedTabs(noteContextsToRemove, position);\n\n        this.triggerEvent('noteContextRemoved', {ntxIds: ntxIdsToRemove});\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    addToRecentlyClosedTabs(noteContexts, position) {\n        if (noteContexts.length === 1 && noteContexts[0].isEmpty()) {\n            return;\n        }\n\n        this.recentlyClosedTabs.push({contexts: noteContexts, position: position});\n    }\n\n    tabReorderEvent({ntxIdsInOrder}) {\n        const order = {};\n\n        let i = 0;\n\n        for (const ntxId of ntxIdsInOrder) {\n            for (const noteContext of this.getNoteContextById(ntxId).getSubContexts()) {\n                order[noteContext.ntxId] = i++;\n            }\n        }\n\n        this.children.sort((a, b) => order[a.ntxId] < order[b.ntxId] ? -1 : 1);\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    noteContextReorderEvent({ntxIdsInOrder, oldMainNtxId, newMainNtxId}) {\n        const order = Object.fromEntries(ntxIdsInOrder.map((v, i) => [v, i]));\n\n        this.children.sort((a, b) => order[a.ntxId] < order[b.ntxId] ? -1 : 1);\n\n        if (oldMainNtxId && newMainNtxId) {\n            this.children.forEach(c => {\n                if (c.ntxId === newMainNtxId) {\n                    // new main context has null mainNtxId\n                    c.mainNtxId = null;\n                } else if (c.ntxId === oldMainNtxId || c.mainNtxId === oldMainNtxId) {\n                    // old main context or subcontexts all have the new mainNtxId\n                    c.mainNtxId = newMainNtxId;\n                }\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    async activateNextTabCommand() {\n        const activeMainNtxId = this.getActiveMainContext().ntxId;\n\n        const oldIdx = this.mainNoteContexts.findIndex(nc => nc.ntxId === activeMainNtxId);\n        const newActiveNtxId = this.mainNoteContexts[oldIdx === this.mainNoteContexts.length - 1 ? 0 : oldIdx + 1].ntxId;\n\n        await this.activateNoteContext(newActiveNtxId);\n    }\n\n    async activatePreviousTabCommand() {\n        const activeMainNtxId = this.getActiveMainContext().ntxId;\n\n        const oldIdx = this.mainNoteContexts.findIndex(nc => nc.ntxId === activeMainNtxId);\n        const newActiveNtxId = this.mainNoteContexts[oldIdx === 0 ? this.mainNoteContexts.length - 1 : oldIdx - 1].ntxId;\n\n        await this.activateNoteContext(newActiveNtxId);\n    }\n\n    async closeActiveTabCommand() {\n        await this.removeNoteContext(this.activeNtxId);\n    }\n\n    beforeUnloadEvent() {\n        this.tabsUpdate.updateNowIfNecessary();\n\n        return true; // don't block closing the tab, this metadata is not that important\n    }\n\n    openNewTabCommand() {\n        this.openAndActivateEmptyTab();\n    }\n\n    async closeAllTabsCommand() {\n        for (const ntxIdToRemove of this.mainNoteContexts.map(nc => nc.ntxId)) {\n            await this.removeNoteContext(ntxIdToRemove);\n        }\n    }\n\n    async closeOtherTabsCommand({ntxId}) {\n        for (const ntxIdToRemove of this.mainNoteContexts.map(nc => nc.ntxId)) {\n            if (ntxIdToRemove !== ntxId) {\n                await this.removeNoteContext(ntxIdToRemove);\n            }\n        }\n    }\n\n    async closeTabCommand({ntxId}) {\n        await this.removeNoteContext(ntxId);\n    }\n\n    async moveTabToNewWindowCommand({ntxId}) {\n        const {notePath, hoistedNoteId} = this.getNoteContextById(ntxId);\n\n        const removed = await this.removeNoteContext(ntxId);\n\n        if (removed) {\n            this.triggerCommand('openInWindow', {notePath, hoistedNoteId});\n        }\n    }\n\n    async reopenLastTabCommand() {\n        let closeLastEmptyTab = null;\n\n        await this.mutex.runExclusively(async () => {\n            if (this.recentlyClosedTabs.length === 0) {\n                return;\n            }\n\n            if (this.noteContexts.length === 1 && this.noteContexts[0].isEmpty()) {\n                // new empty tab is created after closing the last tab, this reverses the empty tab creation\n                closeLastEmptyTab = this.noteContexts[0];\n            }\n\n            const lastClosedTab = this.recentlyClosedTabs.pop();\n            const noteContexts = lastClosedTab.contexts;\n\n            for (const noteContext of noteContexts) {\n                this.child(noteContext);\n\n                await this.triggerEvent('newNoteContextCreated', {noteContext});\n            }\n\n            //  restore last position of contexts stored in tab manager\n            const ntxsInOrder = [\n                ...this.noteContexts.slice(0, lastClosedTab.position),\n                ...this.noteContexts.slice(-noteContexts.length),\n                ...this.noteContexts.slice(lastClosedTab.position, -noteContexts.length),\n            ]\n            await this.noteContextReorderEvent({ntxIdsInOrder: ntxsInOrder.map(nc => nc.ntxId)});\n\n            let mainNtx = noteContexts.find(nc => nc.isMainContext());\n            if (mainNtx) {\n                // reopened a tab, need to reorder new tab widget in tab row\n                await this.triggerEvent('contextsReopened', {\n                    mainNtxId: mainNtx.ntxId,\n                    tabPosition: ntxsInOrder.filter(nc => nc.isMainContext()).findIndex(nc => nc.ntxId === mainNtx.ntxId)\n                });\n            } else {\n                // reopened a single split, need to reorder the pane widget in split note container\n                await this.triggerEvent('contextsReopened', {\n                    ntxId: ntxsInOrder[lastClosedTab.position].ntxId,\n                    // this is safe since lastClosedTab.position can never be 0 in this case\n                    afterNtxId: ntxsInOrder[lastClosedTab.position - 1].ntxId\n                });\n            }\n\n            const noteContextToActivate = noteContexts.length === 1\n                ? noteContexts[0]\n                : noteContexts.find(nc => nc.isMainContext());\n\n            await this.activateNoteContext(noteContextToActivate.ntxId);\n\n            await this.triggerEvent('noteSwitched', {\n                noteContext: noteContextToActivate,\n                notePath: noteContextToActivate.notePath\n            });\n        });\n\n        if (closeLastEmptyTab) {\n            await this.removeNoteContext(closeLastEmptyTab.ntxId);\n        }\n    }\n\n    hoistedNoteChangedEvent() {\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    async updateDocumentTitle(activeNoteContext) {\n        const titleFragments = [\n            // it helps to navigate in history if note title is included in the title\n            await activeNoteContext.getNavigationTitle(),\n            \"Trilium Notes\"\n        ].filter(Boolean);\n\n        document.title = titleFragments.join(\" - \");\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        const activeContext = this.getActiveContext();\n\n        if (activeContext && loadResults.isNoteReloaded(activeContext.noteId)) {\n            await this.updateDocumentTitle(activeContext);\n        }\n    }\n\n    async frocaReloadedEvent() {\n        const activeContext = this.getActiveContext();\n\n        if (activeContext) {\n            await this.updateDocumentTitle(activeContext);\n        }\n    }\n}\n","import Component from \"./component.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class MobileScreenSwitcherExecutor extends Component {\n    setActiveScreenCommand({screen}) {\n        if (screen !== this.activeScreen) {\n            this.activeScreen = screen;\n\n            if (screen === 'tree') {\n                const activeNoteContext = appContext.tabManager.getActiveContext();\n\n                activeNoteContext.setEmpty();\n            }\n\n            this.triggerEvent('activeScreenChanged', {activeScreen: screen});\n        }\n    }\n}\n","import appContext from \"./app_context.js\";\nimport noteCreateService from \"../services/note_create.js\";\nimport treeService from \"../services/tree.js\";\nimport hoistedNoteService from \"../services/hoisted_note.js\";\nimport Component from \"./component.js\";\n\n/**\n * This class contains command executors which logically belong to the NoteTree widget, but for better user experience,\n * the keyboard shortcuts must be active on the whole screen and not just on the widget itself, so the executors\n * must be at the root of the component tree.\n */\nexport default class MainTreeExecutors extends Component {\n    get tree() {\n        return appContext.noteTreeWidget;\n    }\n\n    async cloneNotesToCommand() {\n        const selectedOrActiveNoteIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.noteId);\n\n        this.triggerCommand('cloneNoteIdsTo', {noteIds: selectedOrActiveNoteIds});\n    }\n\n    async moveNotesToCommand() {\n        const selectedOrActiveBranchIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.branchId);\n\n        this.triggerCommand('moveBranchIdsTo', {branchIds: selectedOrActiveBranchIds});\n    }\n\n    async createNoteIntoCommand() {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (!activeNoteContext) {\n            return;\n        }\n\n        await noteCreateService.createNote(activeNoteContext.notePath, {\n            isProtected: activeNoteContext.note.isProtected,\n            saveSelection: false\n        });\n    }\n\n    async createNoteAfterCommand() {\n        const node = this.tree.getActiveNode();\n\n        if (!node) {\n            return;\n        }\n\n        const parentNotePath = treeService.getNotePath(node.getParent());\n        const isProtected = treeService.getParentProtectedStatus(node);\n\n        if (node.data.noteId === 'root' || node.data.noteId === hoistedNoteService.getHoistedNoteId()) {\n            return;\n        }\n\n        await noteCreateService.createNote(parentNotePath, {\n            target: 'after',\n            targetBranchId: node.data.branchId,\n            isProtected: isProtected,\n            saveSelection: false\n        });\n    }\n}\n","import appContext from \"./app_context.js\";\nimport shortcutService from \"../services/shortcuts.js\";\nimport server from \"../services/server.js\";\nimport Component from \"./component.js\";\nimport froca from \"../services/froca.js\";\n\nexport default class ShortcutComponent extends Component {\n    constructor() {\n        super();\n\n        server.get('keyboard-shortcuts-for-notes').then(shortcutAttributes => {\n            for (const attr of shortcutAttributes) {\n                this.bindNoteShortcutHandler(attr);\n            }\n        });\n    }\n\n    bindNoteShortcutHandler(labelOrRow) {\n        const handler = () => appContext.tabManager.getActiveContext().setNote(labelOrRow.noteId);\n        const namespace = labelOrRow.attributeId;\n\n        if (labelOrRow.isDeleted) { // only applicable if row\n            shortcutService.removeGlobalShortcut(namespace);\n        } else {\n            shortcutService.bindGlobalShortcut(labelOrRow.value, handler, namespace);\n        }\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        for (const attr of loadResults.getAttributeRows()) {\n            if (attr.type === 'label' && attr.name === 'keyboardShortcut') {\n                const note = await froca.getNote(attr.noteId);\n                // launcher shortcuts are handled specifically\n                if (note && note.type !== 'launcher') {\n                    this.bindNoteShortcutHandler(attr);\n                }\n            }\n        }\n    }\n}\n","import froca from \"../services/froca.js\";\nimport bundleService from \"../services/bundle.js\";\nimport RootCommandExecutor from \"./root_command_executor.js\";\nimport Entrypoints from \"./entrypoints.js\";\nimport options from \"../services/options.js\";\nimport utils from \"../services/utils.js\";\nimport zoomComponent from \"./zoom.js\";\nimport TabManager from \"./tab_manager.js\";\nimport Component from \"./component.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\nimport linkService from \"../services/link.js\";\nimport MobileScreenSwitcherExecutor from \"./mobile_screen_switcher.js\";\nimport MainTreeExecutors from \"./main_tree_executors.js\";\nimport toast from \"../services/toast.js\";\nimport ShortcutComponent from \"./shortcut_component.js\";\n\nclass AppContext extends Component {\n    constructor(isMainWindow) {\n        super();\n\n        this.isMainWindow = isMainWindow;\n        // non-widget/layout components needed for the application\n        this.components = [];\n        this.beforeUnloadListeners = [];\n    }\n\n    setLayout(layout) {\n        this.layout = layout;\n    }\n\n    async start() {\n        this.initComponents();\n\n        // options are often needed for isEnabled()\n        await options.initializedPromise;\n\n        this.renderWidgets();\n\n        await froca.initializedPromise;\n\n        this.tabManager.loadTabs();\n\n        setTimeout(() => bundleService.executeStartupBundles(), 2000);\n    }\n\n    initComponents() {\n        this.tabManager = new TabManager();\n\n        this.components = [\n            this.tabManager,\n            new RootCommandExecutor(),\n            new Entrypoints(),\n            new MainTreeExecutors(),\n            new ShortcutComponent()\n        ];\n\n        if (utils.isMobile()) {\n            this.components.push(new MobileScreenSwitcherExecutor());\n        }\n\n        for (const component of this.components) {\n            this.child(component);\n        }\n\n        if (utils.isElectron()) {\n            this.child(zoomComponent);\n        }\n    }\n\n    renderWidgets() {\n        const rootWidget = this.layout.getRootWidget(this);\n        const $renderedWidget = rootWidget.render();\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        $(\"body\").append($renderedWidget);\n\n        $renderedWidget.on('click', \"[data-trigger-command]\", function() {\n            if ($(this).hasClass(\"disabled\")) {\n                return;\n            }\n\n            const commandName = $(this).attr('data-trigger-command');\n            const $component = $(this).closest(\".component\");\n            const component = $component.prop(\"component\");\n\n            component.triggerCommand(commandName, {$el: $(this)});\n        });\n\n        this.child(rootWidget);\n\n        this.triggerEvent('initialRenderComplete');\n    }\n\n    /** @returns {Promise<void>} */\n    triggerEvent(name, data = {}) {\n        return this.handleEvent(name, data);\n    }\n\n    /** @returns {Promise<*>} */\n    triggerCommand(name, data = {}) {\n        for (const executor of this.components) {\n            const fun = executor[`${name}Command`];\n\n            if (fun) {\n                return executor.callMethod(fun, data);\n            }\n        }\n\n        // this might hint at error, but sometimes this is used by components which are at different places\n        // in the component tree to communicate with each other\n        console.debug(`Unhandled command ${name}, converting to event.`);\n\n        return this.triggerEvent(name, data);\n    }\n\n    getComponentByEl(el) {\n        return $(el).closest(\".component\").prop('component');\n    }\n\n    addBeforeUnloadListener(obj) {\n        if (typeof WeakRef !== \"function\") {\n            // older browsers don't support WeakRef\n            return;\n        }\n\n        this.beforeUnloadListeners.push(new WeakRef(obj));\n    }\n}\n\nconst appContext = new AppContext(window.glob.isMainWindow);\n\n// we should save all outstanding changes before the page/app is closed\n$(window).on('beforeunload', () => {\n    let allSaved = true;\n\n    appContext.beforeUnloadListeners = appContext.beforeUnloadListeners.filter(wr => !!wr.deref());\n\n    for (const weakRef of appContext.beforeUnloadListeners) {\n        const component = weakRef.deref();\n\n        if (!component) {\n            continue;\n        }\n\n        if (!component.beforeUnloadEvent()) {\n            console.log(`Component ${component.componentId} is not finished saving its state.`);\n\n            toast.showMessage(\"请等待几秒钟以完成保存, 然后可以重试.\", 10000);\n\n            allSaved = false;\n        }\n    }\n\n    if (!allSaved) {\n        return \"some string\";\n    }\n});\n\n$(window).on('hashchange', function() {\n    const {notePath, ntxId, viewScope} = linkService.parseNavigationStateFromUrl(window.location.href);\n\n    if (notePath || ntxId) {\n        appContext.tabManager.switchToNoteContext(ntxId, notePath, viewScope);\n    }\n});\n\nexport default appContext;\n","import utils from '../services/utils.js';\n\n/**\n * Abstract class for all components in the Trilium's frontend.\n *\n * Contains also event implementation with following properties:\n * - event / command distribution is synchronous which among others mean that events are well-ordered - event\n *   which was sent out first will also be processed first by the component\n * - execution of the event / command is asynchronous - each component executes the event on its own without regard for\n *   other components.\n * - although the execution is async, we are collecting all the promises, and therefore it is possible to wait until the\n *   event / command is executed in all components - by simply awaiting the `triggerEvent()`.\n */\nexport default class Component {\n    constructor() {\n        this.componentId = `${this.sanitizedClassName}-${utils.randomString(8)}`;\n        /** @type Component[] */\n        this.children = [];\n        this.initialized = null;\n    }\n\n    get sanitizedClassName() {\n        // webpack mangles names and sometimes uses unsafe characters\n        return this.constructor.name.replace(/[^A-Z0-9]/ig, \"_\");\n    }\n\n    setParent(parent) {\n        /** @type Component */\n        this.parent = parent;\n        return this;\n    }\n\n    child(...components) {\n        for (const component of components) {\n            component.setParent(this);\n\n            this.children.push(component);\n        }\n\n        return this;\n    }\n\n    /** @returns {Promise<void>} */\n    handleEvent(name, data) {\n        try {\n            const callMethodPromise = this.initialized\n                ? this.initialized.then(() => this.callMethod(this[`${name}Event`], data))\n                : this.callMethod(this[`${name}Event`], data);\n\n            const childrenPromise = this.handleEventInChildren(name, data);\n\n            // don't create promises if not needed (optimization)\n            return callMethodPromise && childrenPromise\n                ? Promise.all([callMethodPromise, childrenPromise])\n                : (callMethodPromise || childrenPromise);\n        }\n        catch (e) {\n            console.error(`Handling of event '${name}' failed in ${this.constructor.name} with error ${e.message} ${e.stack}`);\n\n            return null;\n        }\n    }\n\n    /** @returns {Promise<void>} */\n    triggerEvent(name, data = {}) {\n        return this.parent.triggerEvent(name, data);\n    }\n\n    /** @returns {Promise<void>} */\n    handleEventInChildren(name, data = {}) {\n        const promises = [];\n\n        for (const child of this.children) {\n            const ret = child.handleEvent(name, data);\n\n            if (ret) {\n                promises.push(ret);\n            }\n        }\n\n        // don't create promises if not needed (optimization)\n        return promises.length > 0 ? Promise.all(promises) : null;\n    }\n\n    /** @returns {Promise<*>} */\n    triggerCommand(name, data = {}) {\n        const fun = this[`${name}Command`];\n\n        if (fun) {\n            return this.callMethod(fun, data);\n        }\n        else {\n            return this.parent.triggerCommand(name, data);\n        }\n    }\n\n    callMethod(fun, data) {\n        if (typeof fun !== 'function') {\n            return;\n        }\n\n        const startTime = Date.now();\n\n        const promise = fun.call(this, data);\n\n        const took = Date.now() - startTime;\n\n        if (glob.isDev && took > 20) { // measuring only sync handlers\n            console.log(`Call to ${fun.name} in ${this.componentId} took ${took}ms`);\n        }\n\n        if (glob.isDev && promise) {\n            return utils.timeLimit(promise, 20000, `Time limit failed on ${this.constructor.name} with ${fun.name}`);\n        }\n\n        return promise;\n    }\n}\n","import options from \"../services/options.js\";\nimport Component from \"./component.js\";\nimport utils from \"../services/utils.js\";\n\nconst MIN_ZOOM = 0.5;\nconst MAX_ZOOM = 2.0;\n\nclass ZoomComponent extends Component {\n    constructor() {\n        super();\n\n        if (utils.isElectron()) {\n            options.initializedPromise.then(() => {\n                this.setZoomFactor(options.getFloat('zoomFactor'));\n            });\n\n            window.addEventListener(\"wheel\", event => {\n                if (event.ctrlKey) {\n                    this.setZoomFactorAndSave(this.getCurrentZoom() + event.deltaY * 0.001);\n                }\n            });\n        }\n    }\n\n    setZoomFactor(zoomFactor) {\n        zoomFactor = parseFloat(zoomFactor);\n\n        const webFrame = utils.dynamicRequire('electron').webFrame;\n        webFrame.setZoomFactor(zoomFactor);\n    }\n\n    async setZoomFactorAndSave(zoomFactor) {\n        if (zoomFactor >= MIN_ZOOM && zoomFactor <= MAX_ZOOM) {\n            zoomFactor = Math.round(zoomFactor * 10) / 10;\n\n            this.setZoomFactor(zoomFactor);\n\n            await options.save('zoomFactor', zoomFactor);\n        }\n        else {\n            console.log(`Zoom factor ${zoomFactor} outside of the range, ignored.`);\n        }\n    }\n\n    getCurrentZoom() {\n        return utils.dynamicRequire('electron').webFrame.getZoomFactor();\n    }\n\n    zoomOutEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() - 0.1);\n    }\n\n    zoomInEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() + 0.1);\n    }\n    zoomResetEvent() {\n        this.setZoomFactorAndSave(1);\n    }\n    \n    setZoomFactorAndSaveEvent({zoomFactor}) {\n        this.setZoomFactorAndSave(zoomFactor);\n    }\n}\n\nconst zoomService = new ZoomComponent();\n\nexport default zoomService;\n","/**\n * Attachment is a file directly tied into a note without\n * being a hidden child.\n */\nclass FAttachment {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.attachmentId = row.attachmentId;\n        /** @type {string} */\n        this.ownerId = row.ownerId;\n        /** @type {string} */\n        this.role = row.role;\n        /** @type {string} */\n        this.mime = row.mime;\n        /** @type {string} */\n        this.title = row.title;\n        /** @type {string} */\n        this.dateModified = row.dateModified;\n        /** @type {string} */\n        this.utcDateModified = row.utcDateModified;\n        /** @type {string} */\n        this.utcDateScheduledForErasureSince = row.utcDateScheduledForErasureSince;\n\n        /**\n         * optionally added to the entity \n         * @type {int}\n         */\n        this.contentLength = row.contentLength;\n\n        this.froca.attachments[this.attachmentId] = this;\n    }\n\n    /** @returns {FNote} */\n    getNote() {\n        return this.froca.notes[this.ownerId];\n    }\n\n    /** @return {FBlob} */\n    async getBlob() {\n        return await this.froca.getBlob('attachments', this.attachmentId);\n    }\n}\n\nexport default FAttachment;\n","import promotedAttributeDefinitionParser from '../services/promoted_attribute_definition_parser.js';\n\n/**\n * There are currently only two types of attributes, labels or relations.\n * @typedef {\"label\" | \"relation\"} AttributeType\n */\n\n/**\n * Attribute is an abstract concept which has two real uses - label (key - value pair)\n * and relation (representing named relationship between source and target note)\n */\nclass FAttribute {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.attributeId = row.attributeId;\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {AttributeType} */\n        this.type = row.type;\n        /** @type {string} */\n        this.name = row.name;\n        /** @type {string} */\n        this.value = row.value;\n        /** @type {int} */\n        this.position = row.position;\n        /** @type {boolean} */\n        this.isInheritable = !!row.isInheritable;\n    }\n\n    /** @returns {FNote} */\n    getNote() {\n        return this.froca.notes[this.noteId];\n    }\n\n    /** @returns {Promise<FNote>} */\n    async getTargetNote() {\n        const targetNoteId = this.targetNoteId;\n\n        return await this.froca.getNote(targetNoteId, true);\n    }\n\n    get targetNoteId() { // alias\n        if (this.type !== 'relation') {\n            throw new Error(`Attribute ${this.attributeId} is not a relation`);\n        }\n\n        return this.value;\n    }\n\n    get isAutoLink() {\n        return this.type === 'relation' && ['internalLink', 'imageLink', 'relationMapLink', 'includeNoteLink'].includes(this.name);\n    }\n\n    get toString() {\n        return `FAttribute(attributeId=${this.attributeId}, type=${this.type}, name=${this.name}, value=${this.value})`;\n    }\n\n    isDefinition() {\n        return this.type === 'label' && (this.name.startsWith('label:') || this.name.startsWith('relation:'));\n    }\n\n    getDefinition() {\n        return promotedAttributeDefinitionParser.parse(this.value);\n    }\n\n    isDefinitionFor(attr) {\n        return this.type === 'label' && this.name === `${attr.type}:${attr.name}`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.froca;\n\n        return dto;\n    }\n}\n\nexport default FAttribute;\n","/**\n * Branch represents a relationship between a child note and its parent note. Trilium allows a note to have multiple\n * parents.\n */\nclass FBranch {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /**\n         * primary key\n         * @type {string}\n         */\n        this.branchId = row.branchId;\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {string} */\n        this.parentNoteId = row.parentNoteId;\n        /** @type {int} */\n        this.notePosition = row.notePosition;\n        /** @type {string} */\n        this.prefix = row.prefix;\n        /** @type {boolean} */\n        this.isExpanded = !!row.isExpanded;\n        /** @type {boolean} */\n        this.fromSearchNote = !!row.fromSearchNote;\n    }\n\n    /** @returns {FNote} */\n    async getNote() {\n        return this.froca.getNote(this.noteId);\n    }\n\n    /** @returns {FNote} */\n    getNoteFromCache() {\n        return this.froca.getNoteFromCache(this.noteId);\n    }\n\n    /** @returns {FNote} */\n    async getParentNote() {\n        return this.froca.getNote(this.parentNoteId);\n    }\n\n    /** @returns {boolean} true if it's top level, meaning its parent is the root note */\n    isTopLevel() {\n        return this.parentNoteId === 'root';\n    }\n\n    get toString() {\n        return `FBranch(branchId=${this.branchId})`;\n    }\n\n    get pojo() {\n        const pojo = {...this};\n        delete pojo.froca;\n        return pojo;\n    }\n}\n\nexport default FBranch;\n","const registeredClasses = new Set();\n\nfunction createClassForColor(color) {\n    if (!color?.trim()) {\n        return \"\";\n    }\n\n    const normalizedColorName = color.replace(/[^a-z0-9]/gi, \"\");\n\n    if (!normalizedColorName.trim()) {\n        return \"\";\n    }\n\n    const className = `color-${normalizedColorName}`;\n\n    if (!registeredClasses.has(className)) {\n        // make the active fancytree selector more specific than the normal color setting\n        $(\"head\").append(`<style>.${className}, span.fancytree-active.${className} { color: ${color} !important; }</style>`);\n\n        registeredClasses.add(className);\n    }\n\n    return className;\n}\n\nexport default {\n    createClassForColor\n};\n","import server from '../services/server.js';\nimport noteAttributeCache from \"../services/note_attribute_cache.js\";\nimport ws from \"../services/ws.js\";\nimport froca from \"../services/froca.js\";\nimport protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport cssClassManager from \"../services/css_class_manager.js\";\n\nconst LABEL = 'label';\nconst RELATION = 'relation';\n\nconst NOTE_TYPE_ICONS = {\n    \"file\": \"bx bx-file\",\n    \"image\": \"bx bx-image\",\n    \"code\": \"bx bx-code\",\n    \"render\": \"bx bx-extension\",\n    \"search\": \"bx bx-file-find\",\n    \"relationMap\": \"bx bx-map-alt\",\n    \"book\": \"bx bx-book\",\n    \"noteMap\": \"bx bx-map-alt\",\n    \"mermaid\": \"bx bx-selection\",\n    \"canvas\": \"bx bx-pen\",\n    \"webView\": \"bx bx-globe-alt\",\n    \"launcher\": \"bx bx-link\",\n    \"doc\": \"bx bxs-file-doc\",\n    \"contentWidget\": \"bx bxs-widget\"\n};\n\n/**\n * There are many different Note types, some of which are entirely opaque to the\n * end user. Those types should be used only for checking against, they are\n * not for direct use.\n * @typedef {\"file\" | \"image\" | \"search\" | \"noteMap\" | \"launcher\" | \"doc\" | \"contentWidget\" | \"text\" | \"relationMap\" | \"render\" | \"canvas\" | \"mermaid\" | \"book\" | \"webView\" | \"code\"} NoteType\n */\n\n/**\n * @typedef {Object} NotePathRecord\n * @property {boolean} isArchived\n * @property {boolean} isInHoistedSubTree\n * @property {boolean} isSearch\n * @property {Array<string>} notePath\n * @property {boolean} isHidden\n */\n\n/**\n * Note is the main node and concept in Trilium.\n */\nclass FNote {\n    /**\n     * @param {Froca} froca\n     * @param {Object.<string, Object>} row\n     */\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        /** @type {string[]} */\n        this.attributes = [];\n\n        /** @type {string[]} */\n        this.targetRelations = [];\n\n        /** @type {string[]} */\n        this.parents = [];\n        /** @type {string[]} */\n        this.children = [];\n\n        /** @type {Object.<string, string>} */\n        this.parentToBranch = {};\n\n        /** @type {Object.<string, string>} */\n        this.childToBranch = {};\n\n        /** @type {FAttachment[]|null} */\n        this.attachments = null; // lazy loaded\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {string} */\n        this.title = row.title;\n        /** @type {boolean} */\n        this.isProtected = !!row.isProtected;\n        /**\n         * See {@see NoteType} for info on values.\n         * @type {NoteType}\n         */\n        this.type = row.type;\n        /**\n         * content-type, e.g. \"application/json\"\n         * @type {string}\n         */\n        this.mime = row.mime;\n\n        // the main use case to keep this is to detect content change which should trigger refresh\n        this.blobId = row.blobId;\n    }\n\n    addParent(parentNoteId, branchId, sort = true) {\n        if (parentNoteId === 'none') {\n            return;\n        }\n\n        if (!this.parents.includes(parentNoteId)) {\n            this.parents.push(parentNoteId);\n        }\n\n        this.parentToBranch[parentNoteId] = branchId;\n\n        if (sort) {\n            this.sortParents();\n        }\n    }\n\n    addChild(childNoteId, branchId, sort = true) {\n        if (!(childNoteId in this.childToBranch)) {\n            this.children.push(childNoteId);\n        }\n\n        this.childToBranch[childNoteId] = branchId;\n\n        if (sort) {\n            this.sortChildren();\n        }\n    }\n\n    sortChildren() {\n        const branchIdPos = {};\n\n        for (const branchId of Object.values(this.childToBranch)) {\n            branchIdPos[branchId] = this.froca.getBranch(branchId).notePosition;\n        }\n\n        this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] - branchIdPos[this.childToBranch[b]]);\n    }\n\n    /** @returns {boolean} */\n    isJson() {\n        return this.mime === \"application/json\";\n    }\n\n    async getContent() {\n        const blob = await this.getBlob();\n\n        return blob?.content;\n    }\n\n    async getJsonContent() {\n        const content = await this.getContent();\n\n        try {\n            return JSON.parse(content);\n        }\n        catch (e) {\n            console.log(`Cannot parse content of note '${this.noteId}': `, e.message);\n\n            return null;\n        }\n    }\n\n    /**\n     * @returns {string[]}\n     */\n    getParentBranchIds() {\n        return Object.values(this.parentToBranch);\n    }\n\n    /**\n     * @returns {string[]}\n     * @deprecated use getParentBranchIds() instead\n     */\n    getBranchIds() {\n        return this.getParentBranchIds();\n    }\n\n    /**\n     * @returns {FBranch[]}\n     */\n    getParentBranches() {\n        const branchIds = Object.values(this.parentToBranch);\n\n        return this.froca.getBranches(branchIds);\n    }\n\n    /**\n     * @returns {FBranch[]}\n     * @deprecated use getParentBranches() instead\n     */\n    getBranches() {\n        return this.getParentBranches();\n    }\n\n    /** @returns {boolean} */\n    hasChildren() {\n        return this.children.length > 0;\n    }\n\n    /** @returns {FBranch[]} */\n    getChildBranches() {\n        // don't use Object.values() to guarantee order\n        const branchIds = this.children.map(childNoteId => this.childToBranch[childNoteId]);\n\n        return this.froca.getBranches(branchIds);\n    }\n\n    /** @returns {string[]} */\n    getParentNoteIds() {\n        return this.parents;\n    }\n\n    /** @returns {FNote[]} */\n    getParentNotes() {\n        return this.froca.getNotesFromCache(this.parents);\n    }\n\n    // will sort the parents so that non-search & non-archived are first and archived at the end\n    // this is done so that non-search & non-archived paths are always explored as first when looking for a note path\n    sortParents() {\n        this.parents.sort((aNoteId, bNoteId) => {\n            const aBranchId = this.parentToBranch[aNoteId];\n\n            if (aBranchId && aBranchId.startsWith('virt-')) {\n                return 1;\n            }\n\n            const aNote = this.froca.getNoteFromCache(aNoteId);\n\n            if (aNote.isArchived || aNote.isHiddenCompletely()) {\n                return 1;\n            }\n\n            return aNoteId < bNoteId ? -1 : 1;\n        });\n    }\n\n    get isArchived() {\n        return this.hasAttribute('label', 'archived');\n    }\n\n    /** @returns {string[]} */\n    getChildNoteIds() {\n        return this.children;\n    }\n\n    /** @returns {Promise<FNote[]>} */\n    async getChildNotes() {\n        return await this.froca.getNotes(this.children);\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachments() {\n        if (!this.attachments) {\n            this.attachments = await this.froca.getAttachmentsForNote(this.noteId);\n        }\n\n        return this.attachments;\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachmentsByRole(role) {\n        return (await this.getAttachments())\n            .filter(attachment => attachment.role === role);\n    }\n\n    /** @returns {Promise<FAttachment>} */\n    async getAttachmentById(attachmentId) {\n        const attachments = await this.getAttachments();\n\n        return attachments.find(att => att.attachmentId === attachmentId);\n    }\n\n    isEligibleForConversionToAttachment() {\n        if (this.type !== 'image' || !this.isContentAvailable() || this.hasChildren() || this.getParentBranches().length !== 1) {\n            return false;\n        }\n\n        const targetRelations = this.getTargetRelations().filter(relation => relation.name === 'imageLink');\n\n        if (targetRelations.length > 1) {\n            return false;\n        }\n\n        const parentNote = this.getParentNotes()[0]; // at this point note can have only one parent\n        const referencingNote = targetRelations[0]?.getNote();\n\n        if (referencingNote && referencingNote !== parentNote) {\n            return false;\n        } else if (parentNote.type !== 'text' || !parentNote.isContentAvailable()) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {FAttribute[]} all note's attributes, including inherited ones\n     */\n    getOwnedAttributes(type, name) {\n        const attrs = this.attributes\n            .map(attributeId => this.froca.attributes[attributeId])\n            .filter(Boolean); // filter out nulls;\n\n        return this.__filterAttrs(attrs, type, name);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {FAttribute[]} all note's attributes, including inherited ones\n     */\n    getAttributes(type, name) {\n        return this.__filterAttrs(this.__getCachedAttributes([]), type, name);\n    }\n\n    /**\n     * @param {string[]} path\n     * @return {FAttribute[]}\n     * @private\n     */\n    __getCachedAttributes(path) {\n        // notes/clones cannot form tree cycles, it is possible to create attribute inheritance cycle via templates\n        // when template instance is a parent of template itself\n        if (path.includes(this.noteId)) {\n            return [];\n        }\n\n        if (!(this.noteId in noteAttributeCache.attributes)) {\n            const newPath = [...path, this.noteId];\n            const attrArrs = [ this.getOwnedAttributes() ];\n\n            // inheritable attrs on root are typically not intended to be applied to hidden subtree #3537\n            if (this.noteId !== 'root' && this.noteId !== '_hidden') {\n                for (const parentNote of this.getParentNotes()) {\n                    // these virtual parent-child relationships are also loaded into froca\n                    if (parentNote.type !== 'search') {\n                        attrArrs.push(parentNote.__getInheritableAttributes(newPath));\n                    }\n                }\n            }\n\n            for (const templateAttr of attrArrs.flat().filter(attr => attr.type === 'relation' && ['template', 'inherit'].includes(attr.name))) {\n                const templateNote = this.froca.notes[templateAttr.value];\n\n                if (templateNote && templateNote.noteId !== this.noteId) {\n                    attrArrs.push(\n                        templateNote.__getCachedAttributes(newPath)\n                            // template attr is used as a marker for templates, but it's not meant to be inherited\n                            .filter(attr => !(attr.type === 'label' && (attr.name === 'template' || attr.name === 'workspacetemplate')))\n                    );\n                }\n            }\n\n            noteAttributeCache.attributes[this.noteId] = [];\n            const addedAttributeIds = new Set();\n\n            for (const attr of attrArrs.flat()) {\n                if (!addedAttributeIds.has(attr.attributeId)) {\n                    addedAttributeIds.add(attr.attributeId);\n\n                    noteAttributeCache.attributes[this.noteId].push(attr);\n                }\n            }\n        }\n\n        return noteAttributeCache.attributes[this.noteId];\n    }\n\n    isRoot() {\n        return this.noteId === 'root';\n    }\n\n    /**\n     * Gives all possible note paths leading to this note. Paths containing search note are ignored (could form cycles)\n     *\n     * @returns {string[][]} - array of notePaths (each represented by array of noteIds constituting the particular note path)\n     */\n    getAllNotePaths() {\n        if (this.noteId === 'root') {\n            return [['root']];\n        }\n\n        const parentNotes = this.getParentNotes().filter(note => note.type !== 'search');\n\n        const notePaths = parentNotes.length === 1\n            ? parentNotes[0].getAllNotePaths() // optimization for the most common case\n            : parentNotes.flatMap(parentNote => parentNote.getAllNotePaths());\n\n        for (const notePath of notePaths) {\n            notePath.push(this.noteId);\n        }\n\n        return notePaths;\n    }\n\n    /**\n     * @param {string} [hoistedNoteId='root']\n     * @return {Array<NotePathRecord>}\n     */\n    getSortedNotePathRecords(hoistedNoteId = 'root') {\n        const isHoistedRoot = hoistedNoteId === 'root';\n\n        const notePaths = this.getAllNotePaths().map(path => ({\n            notePath: path,\n            isInHoistedSubTree: isHoistedRoot || path.includes(hoistedNoteId),\n            isArchived: path.some(noteId => froca.notes[noteId].isArchived),\n            isSearch: path.find(noteId => froca.notes[noteId].type === 'search'),\n            isHidden: path.includes('_hidden')\n        }));\n\n        notePaths.sort((a, b) => {\n            if (a.isInHoistedSubTree !== b.isInHoistedSubTree) {\n                return a.isInHoistedSubTree ? -1 : 1;\n            } else if (a.isArchived !== b.isArchived) {\n                return a.isArchived ? 1 : -1;\n            } else if (a.isHidden !== b.isHidden) {\n                return a.isHidden ? 1 : -1;\n            } else if (a.isSearch !== b.isSearch) {\n                return a.isSearch ? 1 : -1;\n            } else {\n                return a.notePath.length - b.notePath.length;\n            }\n        });\n\n        return notePaths;\n    }\n\n    /**\n     * Returns the note path considered to be the \"best\"\n     *\n     * @param {string} [hoistedNoteId='root']\n     * @return {string[]} array of noteIds constituting the particular note path\n     */\n    getBestNotePath(hoistedNoteId = 'root') {\n        return this.getSortedNotePathRecords(hoistedNoteId)[0]?.notePath;\n    }\n\n    /**\n     * Returns the note path considered to be the \"best\"\n     *\n     * @param {string} [hoistedNoteId='root']\n     * @return {string} serialized note path (e.g. 'root/a1h315/js725h')\n     */\n    getBestNotePathString(hoistedNoteId = 'root') {\n        const notePath = this.getBestNotePath(hoistedNoteId);\n\n        return notePath?.join(\"/\");\n    }\n\n    /**\n     * @return boolean - true if there's no non-hidden path, note is not cloned to the visible tree\n     */\n    isHiddenCompletely() {\n        if (this.noteId === '_hidden') {\n            return true;\n        } else if (this.noteId === 'root') {\n            return false;\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.noteId === 'root') {\n                return false;\n            } else if (parentNote.noteId === '_hidden' || parentNote.type === 'search') {\n                continue;\n            }\n\n            if (!parentNote.isHiddenCompletely()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {FAttribute[]} attributes\n     * @param {AttributeType} type\n     * @param {string} name\n     * @return {FAttribute[]}\n     * @private\n     */\n    __filterAttrs(attributes, type, name) {\n        this.__validateTypeName(type, name);\n\n        if (!type && !name) {\n            return attributes;\n        } else if (type && name) {\n            return attributes.filter(attr => attr.name === name && attr.type === type);\n        } else if (type) {\n            return attributes.filter(attr => attr.type === type);\n        } else if (name) {\n            return attributes.filter(attr => attr.name === name);\n        }\n    }\n\n    __getInheritableAttributes(path) {\n        const attrs = this.__getCachedAttributes(path);\n\n        return attrs.filter(attr => attr.isInheritable);\n    }\n\n    __validateTypeName(type, name) {\n        if (type && type !== 'label' && type !== 'relation') {\n            throw new Error(`Unrecognized attribute type '${type}'. Only 'label' and 'relation' are possible values.`);\n        }\n\n        if (name) {\n            const firstLetter = name.charAt(0);\n            if (firstLetter === '#' || firstLetter === '~') {\n                throw new Error(`Detect '#' or '~' in the attribute's name. In the API, attribute names should be set without these characters.`);\n            }\n        }\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {FAttribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getOwnedLabels(name) {\n        return this.getOwnedAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {FAttribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getLabels(name) {\n        return this.getAttributes(LABEL, name);\n    }\n\n    getIcon() {\n        const iconClassLabels = this.getLabels('iconClass');\n        const workspaceIconClass = this.getWorkspaceIconClass();\n\n        if (iconClassLabels.length > 0) {\n            return iconClassLabels[0].value;\n        }\n        else if (workspaceIconClass) {\n            return workspaceIconClass;\n        }\n        else if (this.noteId === 'root') {\n            return \"bx bx-chevrons-right\";\n        }\n        if (this.noteId === '_share') {\n            return \"bx bx-share-alt\";\n        }\n        else if (this.type === 'text') {\n            if (this.isFolder()) {\n                return \"bx bx-folder\";\n            }\n            else {\n                return \"bx bx-note\";\n            }\n        }\n        else if (this.type === 'code' && this.mime.startsWith('text/x-sql')) {\n            return \"bx bx-data\";\n        }\n        else {\n            return NOTE_TYPE_ICONS[this.type];\n        }\n    }\n\n    getColorClass() {\n        const color = this.getLabelValue(\"color\");\n        return cssClassManager.createClassForColor(color);\n    }\n\n    isFolder() {\n        return this.type === 'search'\n            || this.getFilteredChildBranches().length > 0;\n    }\n\n    getFilteredChildBranches() {\n        let childBranches = this.getChildBranches();\n\n        if (!childBranches) {\n            ws.logError(`No children for '${this.noteId}'. This shouldn't happen.`);\n            return;\n        }\n\n        // we're not checking hideArchivedNotes since that would mean we need to lazy load the child notes\n        // which would seriously slow down everything.\n        // we check this flag only once user chooses to expand the parent. This has the negative consequence that\n        // note may appear as a folder but not contain any children when all of them are archived\n\n        return childBranches;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {FAttribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getOwnedRelations(name) {\n        return this.getOwnedAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {FAttribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getRelations(name) {\n        return this.getAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasAttribute(type, name) {\n        const attributes = this.getAttributes();\n\n        return attributes.some(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasOwnedAttribute(type, name) {\n        return !!this.getOwnedAttribute(type, name);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {FAttribute} attribute of the given type and name. If there are more such attributes, first is returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getOwnedAttribute(type, name) {\n        const attributes = this.getOwnedAttributes();\n\n        return attributes.find(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {FAttribute} attribute of the given type and name. If there are more such attributes, first is returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getAttribute(type, name) {\n        const attributes = this.getAttributes();\n\n        return attributes.find(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of the given type and name or null if no such attribute exists.\n     */\n    getOwnedAttributeValue(type, name) {\n        const attr = this.getOwnedAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of the given type and name or null if no such attribute exists.\n     */\n    getAttributeValue(type, name) {\n        const attr = this.getAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (excluding inherited)\n     */\n    hasOwnedLabel(name) { return this.hasOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited)\n     */\n    hasLabel(name) { return this.hasAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited) and does not have \"false\" value.\n     */\n    isLabelTruthy(name) {\n        const label = this.getLabel(name);\n\n        if (!label) {\n            return false;\n        }\n\n        return label && label.value !== 'false';\n    }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (excluding inherited)\n     */\n    hasOwnedRelation(name) { return this.hasOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (including inherited)\n     */\n    hasRelation(name) { return this.hasAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {FAttribute} label if it exists, null otherwise\n     */\n    getOwnedLabel(name) { return this.getOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {FAttribute} label if it exists, null otherwise\n     */\n    getLabel(name) { return this.getAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {FAttribute} relation if it exists, null otherwise\n     */\n    getOwnedRelation(name) { return this.getOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {FAttribute} relation if it exists, null otherwise\n     */\n    getRelation(name) { return this.getAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getOwnedLabelValue(name) { return this.getOwnedAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getLabelValue(name) { return this.getAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getOwnedRelationValue(name) { return this.getOwnedAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getRelationValue(name) { return this.getAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name\n     * @returns {Promise<FNote>|null} target note of the relation or null (if target is empty or note was not found)\n     */\n    async getRelationTarget(name) {\n        const targets = await this.getRelationTargets(name);\n\n        return targets.length > 0 ? targets[0] : null;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Promise<FNote[]>}\n     */\n    async getRelationTargets(name) {\n        const relations = this.getRelations(name);\n        const targets = [];\n\n        for (const relation of relations) {\n            targets.push(await this.froca.getNote(relation.value));\n        }\n\n        return targets;\n    }\n\n    /**\n     * @returns {FNote[]}\n     */\n    getNotesToInheritAttributesFrom() {\n        const relations = [\n            ...this.getRelations('template'),\n            ...this.getRelations('inherit')\n        ];\n\n        return relations.map(rel => this.froca.notes[rel.value]);\n    }\n\n    getPromotedDefinitionAttributes() {\n        if (this.isLabelTruthy('hidePromotedAttributes')) {\n            return [];\n        }\n\n        const promotedAttrs = this.getAttributes()\n            .filter(attr => attr.isDefinition())\n            .filter(attr => {\n                const def = attr.getDefinition();\n\n                return def && def.isPromoted;\n            });\n\n        // attrs are not resorted if position changes after the initial load\n        promotedAttrs.sort((a, b) => {\n            if (a.noteId === b.noteId) {\n                return a.position < b.position ? -1 : 1;\n            } else {\n                // inherited promoted attributes should stay grouped: https://github.com/zadam/trilium/issues/3761\n                return a.noteId < b.noteId ? -1 : 1;\n            }\n        });\n\n        return promotedAttrs;\n    }\n\n    hasAncestor(ancestorNoteId, followTemplates = false, visitedNoteIds = null) {\n        if (this.noteId === ancestorNoteId) {\n            return true;\n        }\n\n        if (!visitedNoteIds) {\n            visitedNoteIds = new Set();\n        } else if (visitedNoteIds.has(this.noteId)) {\n            // to avoid infinite cycle when template is descendent of the instance\n            return false;\n        }\n\n        visitedNoteIds.add(this.noteId);\n\n        if (followTemplates) {\n            for (const templateNote of this.getNotesToInheritAttributesFrom()) {\n                if (templateNote.hasAncestor(ancestorNoteId, followTemplates, visitedNoteIds)) {\n                    return true;\n                }\n            }\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.hasAncestor(ancestorNoteId, followTemplates, visitedNoteIds)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    isInHiddenSubtree() {\n        return this.noteId === '_hidden' || this.hasAncestor('_hidden');\n    }\n\n    /**\n     * @deprecated NOOP\n     */\n    invalidateAttributeCache() {}\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {FAttribute[]}\n     */\n    getTargetRelations() {\n        return this.targetRelations\n            .map(attributeId => this.froca.attributes[attributeId]);\n    }\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {Promise<FNote[]>}\n     */\n    async getTargetRelationSourceNotes() {\n        const targetRelations = this.getTargetRelations();\n\n        return await this.froca.getNotes(targetRelations.map(tr => tr.noteId));\n    }\n\n    /**\n     * @deprecated use getBlob() instead\n     * @return {Promise<FBlob>}\n     */\n    async getNoteComplement() {\n        return this.getBlob();\n    }\n\n    /** @return {Promise<FBlob>} */\n    async getBlob() {\n        return await this.froca.getBlob('notes', this.noteId);\n    }\n\n    toString() {\n        return `Note(noteId=${this.noteId}, title=${this.title})`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.froca;\n\n        return dto;\n    }\n\n    getCssClass() {\n        const labels = this.getLabels('cssClass');\n        return labels.map(l => l.value).join(' ');\n    }\n\n    getWorkspaceIconClass() {\n        const labels = this.getLabels('workspaceIconClass');\n        return labels.length > 0 ? labels[0].value : \"\";\n    }\n\n    getWorkspaceTabBackgroundColor() {\n        const labels = this.getLabels('workspaceTabBackgroundColor');\n        return labels.length > 0 ? labels[0].value : \"\";\n    }\n\n    /** @returns {boolean} true if this note is JavaScript (code or file) */\n    isJavaScript() {\n        return (this.type === \"code\" || this.type === \"file\" || this.type === 'launcher')\n            && (this.mime.startsWith(\"application/javascript\")\n                || this.mime === \"application/x-javascript\"\n                || this.mime === \"text/javascript\");\n    }\n\n    /** @returns {boolean} true if this note is HTML */\n    isHtml() {\n        return (this.type === \"code\" || this.type === \"file\" || this.type === \"render\") && this.mime === \"text/html\";\n    }\n\n    /** @returns {string|null} JS script environment - either \"frontend\" or \"backend\" */\n    getScriptEnv() {\n        if (this.isHtml() || (this.isJavaScript() && this.mime.endsWith('env=frontend'))) {\n            return \"frontend\";\n        }\n\n        if (this.type === 'render') {\n            return \"frontend\";\n        }\n\n        if (this.isJavaScript() && this.mime.endsWith('env=backend')) {\n            return \"backend\";\n        }\n\n        return null;\n    }\n\n    async executeScript() {\n        if (!this.isJavaScript()) {\n            throw new Error(`Note ${this.noteId} is of type ${this.type} and mime ${this.mime} and thus cannot be executed`);\n        }\n\n        const env = this.getScriptEnv();\n\n        if (env === \"frontend\") {\n            const bundleService = (await import(\"../services/bundle.js\")).default;\n            return await bundleService.getAndExecuteBundle(this.noteId);\n        }\n        else if (env === \"backend\") {\n            const resp = await server.post(`script/run/${this.noteId}`);\n        }\n        else {\n            throw new Error(`Unrecognized env type ${env} for note ${this.noteId}`);\n        }\n    }\n\n    isShared() {\n        for (const parentNoteId of this.parents) {\n            if (parentNoteId === 'root' || parentNoteId === 'none') {\n                continue;\n            }\n\n            const parentNote = froca.notes[parentNoteId];\n\n            if (!parentNote || parentNote.type === 'search') {\n                continue;\n            }\n\n            if (parentNote.noteId === '_share' || parentNote.isShared()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    isContentAvailable() {\n        return !this.isProtected || protectedSessionHolder.isProtectedSessionAvailable()\n    }\n\n    isLaunchBarConfig() {\n        return this.type === 'launcher' || ['_lbRoot', '_lbAvailableLaunchers', '_lbVisibleLaunchers'].includes(this.noteId);\n    }\n\n    isOptions() {\n        return this.noteId.startsWith(\"_options\");\n    }\n\n    /**\n     * Provides note's date metadata.\n     *\n     * @returns {Promise<{dateCreated: string, utcDateCreated: string, dateModified: string, utcDateModified: string}>}\n     */\n    async getMetadata() {\n        return await server.get(`notes/${this.noteId}/metadata`);\n    }\n}\n\nexport default FNote;\n","import keyboardActionService from '../services/keyboard_actions.js';\n\nclass ContextMenu {\n    constructor() {\n        this.$widget = $(\"#context-menu-container\");\n        this.dateContextMenuOpenedMs = 0;\n\n        $(document).on('click', () => this.hide());\n    }\n\n    async show(options) {\n        this.options = options;\n\n        this.$widget.empty();\n\n        this.addItems(this.$widget, options.items);\n\n        keyboardActionService.updateDisplayedShortcuts(this.$widget);\n\n        this.positionMenu();\n\n        this.dateContextMenuOpenedMs = Date.now();\n    }\n\n    positionMenu() {\n        // the code below tries to detect when dropdown would overflow from page\n        // in such case we'll position it above click coordinates, so it will fit into the client\n\n        const CONTEXT_MENU_PADDING = 5; // How many pixels to pad the context menu from edge of screen\n        const CONTEXT_MENU_OFFSET = 0; // How many pixels to offset the context menu by relative to cursor, see #3157\n\n        const clientHeight = document.documentElement.clientHeight;\n        const clientWidth = document.documentElement.clientWidth;\n        const contextMenuHeight = this.$widget.outerHeight();\n        const contextMenuWidth = this.$widget.outerWidth();\n        let top, left;\n\n        if (this.options.y + contextMenuHeight - CONTEXT_MENU_OFFSET > clientHeight - CONTEXT_MENU_PADDING) {\n            // Overflow: bottom\n            top = clientHeight - contextMenuHeight - CONTEXT_MENU_PADDING;\n        } else if (this.options.y - CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n            // Overflow: top\n            top = CONTEXT_MENU_PADDING;\n        } else {\n            top = this.options.y - CONTEXT_MENU_OFFSET;\n        }\n\n        if (this.options.orientation === 'left') {\n            if (this.options.x + CONTEXT_MENU_OFFSET > clientWidth - CONTEXT_MENU_PADDING) {\n                // Overflow: right\n                left = clientWidth - contextMenuWidth - CONTEXT_MENU_OFFSET;\n            } else if (this.options.x - contextMenuWidth + CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n                // Overflow: left\n                left = CONTEXT_MENU_PADDING;\n            } else {\n                left = this.options.x - contextMenuWidth + CONTEXT_MENU_OFFSET;\n            }\n        } else {\n            if (this.options.x + contextMenuWidth - CONTEXT_MENU_OFFSET > clientWidth - CONTEXT_MENU_PADDING) {\n                // Overflow: right\n                left = clientWidth - contextMenuWidth - CONTEXT_MENU_PADDING;\n            } else if (this.options.x - CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n                // Overflow: left\n                left = CONTEXT_MENU_PADDING;\n            } else {\n                left = this.options.x - CONTEXT_MENU_OFFSET;\n            }\n        }\n\n        this.$widget.css({\n            display: \"block\",\n            top: top,\n            left: left\n        }).addClass(\"show\");\n    }\n\n    addItems($parent, items) {\n        for (const item of items) {\n            if (!item) {\n                continue;\n            }\n\n            if (item.title === '----') {\n                $parent.append($(\"<div>\").addClass(\"dropdown-divider\"));\n            } else {\n                const $icon = $(\"<span>\");\n\n                if (item.uiIcon) {\n                    $icon.addClass(item.uiIcon);\n                } else {\n                    $icon.append(\"&nbsp;\");\n                }\n\n                const $link = $(\"<span>\")\n                    .append($icon)\n                    .append(\" &nbsp; \") // some space between icon and text\n                    .append(item.title);\n\n                const $item = $(\"<li>\")\n                    .addClass(\"dropdown-item\")\n                    .append($link)\n                    .on('contextmenu', e => false)\n                    // important to use mousedown instead of click since the former does not change focus\n                    // (especially important for focused text for spell check)\n                    .on('mousedown', e => {\n                        e.stopPropagation();\n\n                        if (e.which !== 1) { // only left click triggers menu items\n                            return false;\n                        }\n\n                        this.hide();\n\n                        if (item.handler) {\n                            item.handler(item, e);\n                        }\n\n                        this.options.selectMenuItemHandler(item, e);\n\n                        // it's important to stop the propagation especially for sub-menus, otherwise the event\n                        // might be handled again by top-level menu\n                        return false;\n                    });\n\n                if (item.enabled !== undefined && !item.enabled) {\n                    $item.addClass(\"disabled\");\n                }\n\n                if (item.items) {\n                    $item.addClass(\"dropdown-submenu\");\n                    $link.addClass(\"dropdown-toggle\");\n\n                    const $subMenu = $(\"<ul>\").addClass(\"dropdown-menu\");\n\n                    this.addItems($subMenu, item.items);\n\n                    $item.append($subMenu);\n                }\n\n                $parent.append($item);\n            }\n        }\n    }\n\n    hide() {\n        // this date checking comes from change in FF66 - https://github.com/zadam/trilium/issues/468\n        // \"contextmenu\" event also triggers \"click\" event which depending on the timing can close the just opened context menu\n        // we might filter out right clicks, but then it's better if even right clicks close the context menu\n        if (Date.now() - this.dateContextMenuOpenedMs > 300) {\n            // seems like if we hide the menu immediately, some clicks can get propagated to the underlying component\n            // see https://github.com/zadam/trilium/pull/3805 for details\n            setTimeout(() => this.$widget.hide(), 100);\n        }\n    }\n}\n\nconst contextMenu = new ContextMenu();\n\nexport default contextMenu;\n","import contextMenu from \"./context_menu.js\";\nimport appContext from \"../components/app_context.js\";\n\nfunction openContextMenu(notePath, e, viewScope = {}, hoistedNoteId = null) {\n    contextMenu.show({\n        x: e.pageX,\n        y: e.pageY,\n        items: [\n            {title: \"在新标签页中打开笔记\", command: \"openNoteInNewTab\", uiIcon: \"bx bx-empty\"},\n            {title: \"在新的拆分中打开笔记\", command: \"openNoteInNewSplit\", uiIcon: \"bx bx-dock-right\"},\n            {title: \"在新窗口中打开笔记\", command: \"openNoteInNewWindow\", uiIcon: \"bx bx-window-open\"}\n        ],\n        selectMenuItemHandler: ({command}) => {\n            if (!hoistedNoteId) {\n                hoistedNoteId = appContext.tabManager.getActiveContext().hoistedNoteId;\n            }\n\n            if (command === 'openNoteInNewTab') {\n                appContext.tabManager.openContextWithNote(notePath, { hoistedNoteId, viewScope });\n            }\n            else if (command === 'openNoteInNewSplit') {\n                const subContexts = appContext.tabManager.getActiveContext().getSubContexts();\n                const {ntxId} = subContexts[subContexts.length - 1];\n\n                appContext.triggerCommand(\"openNewNoteSplit\", {ntxId, notePath, hoistedNoteId, viewScope});\n            }\n            else if (command === 'openNoteInNewWindow') {\n                appContext.triggerCommand('openInWindow', {notePath, hoistedNoteId, viewScope});\n            }\n        }\n    });\n}\n\nexport default {\n    openContextMenu\n}\n","import ws from \"./ws.js\";\nimport froca from \"./froca.js\";\n\nasync function renderAttribute(attribute, renderIsInheritable) {\n    const isInheritable = renderIsInheritable && attribute.isInheritable ? `(可继承的)` : '';\n    const $attr = $(\"<span>\");\n\n    if (attribute.type === 'label') {\n        $attr.append(document.createTextNode(`#${attribute.name}${isInheritable}`));\n\n        if (attribute.value) {\n            $attr.append('=');\n            $attr.append(document.createTextNode(formatValue(attribute.value)));\n        }\n    } else if (attribute.type === 'relation') {\n        if (attribute.isAutoLink) {\n            return $attr;\n        }\n\n        // when the relation has just been created, then it might not have a value\n        if (attribute.value) {\n            $attr.append(document.createTextNode(`~${attribute.name}${isInheritable}=`));\n            $attr.append(await createLink(attribute.value));\n        }\n    } else {\n        ws.logError(`Unknown attr type: ${attribute.type}`);\n    }\n\n    return $attr;\n}\n\nfunction formatValue(val) {\n    if (/^[\\p{L}\\p{N}\\-_,.]+$/u.test(val)) {\n        return val;\n    }\n    else if (!val.includes('\"')) {\n        return `\"${val}\"`;\n    }\n    else if (!val.includes(\"'\")) {\n        return `'${val}'`;\n    }\n    else if (!val.includes(\"`\")) {\n        return `\\`${val}\\``;\n    }\n    else {\n        return `\"${val.replace(/\"/g, '\\\\\"')}\"`;\n    }\n}\n\nasync function createLink(noteId) {\n    const note = await froca.getNote(noteId);\n\n    if (!note) {\n        return;\n    }\n\n    return $(\"<a>\", {\n        href: `#root/${noteId}`,\n        class: 'reference-link'\n    })\n        .text(note.title);\n}\n\nasync function renderAttributes(attributes, renderIsInheritable) {\n    const $container = $('<span class=\"rendered-note-attributes\">');\n\n    for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i];\n\n        const $attr = await renderAttribute(attribute, renderIsInheritable);\n        $container.append($attr.html()); // .html() to get only inner HTML, we don't want any spans\n\n        if (i < attributes.length - 1) {\n            $container.append(\" \");\n        }\n    }\n\n    return $container;\n}\n\nconst HIDDEN_ATTRIBUTES = [\n    'originalFileName',\n    'fileSize',\n    'template',\n    'inherit',\n    'cssClass',\n    'iconClass',\n    'pageSize',\n    'viewType'\n];\n\nasync function renderNormalAttributes(note) {\n    const promotedDefinitionAttributes = note.getPromotedDefinitionAttributes();\n    let attrs = note.getAttributes();\n\n    if (promotedDefinitionAttributes.length > 0) {\n        attrs = attrs.filter(attr => !!promotedDefinitionAttributes.find(promAttr => promAttr.isDefinitionFor(attr)));\n    }\n    else {\n        attrs = attrs.filter(\n            attr => !attr.isDefinition()\n                 && !attr.isAutoLink\n                 && !HIDDEN_ATTRIBUTES.includes(attr.name)\n                 && attr.noteId === note.noteId\n        );\n    }\n\n    const $renderedAttributes = await renderAttributes(attrs, false);\n\n    return {\n        count: attrs.length,\n        $renderedAttributes\n    }\n}\n\nexport default {\n    renderAttribute,\n    renderAttributes,\n    renderNormalAttributes\n}\n","import ScriptContext from \"./script_context.js\";\nimport server from \"./server.js\";\nimport toastService from \"./toast.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\n\nasync function getAndExecuteBundle(noteId, originEntity = null, script = null, params = null) {\n    const bundle = await server.post(`script/bundle/${noteId}`, {\n        script,\n        params\n    });\n\n    return await executeBundle(bundle, originEntity);\n}\n\nasync function executeBundle(bundle, originEntity, $container) {\n    const apiContext = await ScriptContext(bundle.noteId, bundle.allNoteIds, originEntity, $container);\n\n    try {\n        return await (function () {\n            return eval(`const apiContext = this; (async function() { ${bundle.script}\\r\\n})()`);\n        }.call(apiContext));\n    }\n    catch (e) {\n        const note = await froca.getNote(bundle.noteId);\n\n        toastService.showAndLogError(`执行 ID 为 ${bundle.noteId} 的JS笔记\"${note.title}\"失败, 错误: ${e.message}`);\n    }\n}\n\nasync function executeStartupBundles() {\n    const isMobile = utils.isMobile();\n    const scriptBundles = await server.get(\"script/startup\" + (isMobile ? \"?mobile=true\" : \"\"));\n\n    for (const bundle of scriptBundles) {\n        await executeBundle(bundle);\n    }\n}\n\nclass WidgetsByParent {\n    constructor() {\n        this.byParent = {};\n    }\n\n    add(widget) {\n        if (!widget.parentWidget) {\n            console.log(`Custom widget does not have mandatory 'parentWidget' property defined`);\n            return;\n        }\n\n        this.byParent[widget.parentWidget] = this.byParent[widget.parentWidget] || [];\n        this.byParent[widget.parentWidget].push(widget);\n    }\n\n    get(parentName) {\n        if (!this.byParent[parentName]) {\n            return [];\n        }\n\n        return this.byParent[parentName]\n            // previously, custom widgets were provided as a single instance, but that has the disadvantage\n            // for splits where we actually need multiple instaces and thus having a class to instantiate is better\n            // https://github.com/zadam/trilium/issues/4274\n            .map(w => w.prototype ? new w() : w);\n    }\n}\n\nasync function getWidgetBundlesByParent() {\n    const scriptBundles = await server.get(\"script/widgets\");\n\n    const widgetsByParent = new WidgetsByParent();\n\n    for (const bundle of scriptBundles) {\n        let widget;\n\n        try {\n            widget = await executeBundle(bundle);\n            widgetsByParent.add(widget);\n        }\n        catch (e) {\n            logError(\"小部件初始化失败: \", e);\n            continue;\n        }\n    }\n\n    return widgetsByParent;\n}\n\nexport default {\n    executeBundle,\n    getAndExecuteBundle,\n    executeStartupBundles,\n    getWidgetBundlesByParent\n}\n","import renderService from \"./render.js\";\nimport protectedSessionService from \"./protected_session.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport libraryLoader from \"./library_loader.js\";\nimport openService from \"./open.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport linkService from \"./link.js\";\nimport treeService from \"./tree.js\";\nimport FNote from \"../entities/fnote.js\";\nimport FAttachment from \"../entities/fattachment.js\";\n\nlet idCounter = 1;\n\n/**\n * @param {FNote|FAttachment} entity\n * @param {object} options\n * @return {Promise<{type: string, $renderedContent: jQuery}>}\n */\nasync function getRenderedContent(entity, options = {}) {\n    options = Object.assign({\n        tooltip: false\n    }, options);\n\n    const type = getRenderingType(entity);\n    // attachment supports only image and file/pdf/audio/video\n\n    const $renderedContent = $('<div class=\"rendered-content\">');\n\n    if (type === 'text') {\n        await renderText(entity, $renderedContent);\n    }\n    else if (type === 'code') {\n        await renderCode(entity, $renderedContent);\n    }\n    else if (type === 'image' || type === 'canvas') {\n        renderImage(entity, $renderedContent, options);\n    }\n    else if (!options.tooltip && ['file', 'pdf', 'audio', 'video'].includes(type)) {\n        renderFile(entity, type, $renderedContent);\n    }\n    else if (type === 'mermaid') {\n        await renderMermaid(entity, $renderedContent);\n    }\n    else if (type === 'render') {\n        const $content = $('<div>');\n\n        await renderService.render(entity, $content, this.ctx);\n\n        $renderedContent.append($content);\n    }\n    else if (!options.tooltip && type === 'protectedSession') {\n        const $button = $(`<button class=\"btn btn-sm\"><span class=\"bx bx-log-in\"></span>进入受保护的会话</button>`)\n            .on('click', protectedSessionService.enterProtectedSession);\n\n        $renderedContent.append(\n            $(\"<div>\")\n                .append(\"<div>此笔记受保护, 您需要输入密码来访问它.</div>\")\n                .append(\"<br/>\")\n                .append($button)\n        );\n    }\n    else if (entity instanceof FNote) {\n        $renderedContent.append(\n            $(\"<div>\")\n                .css(\"display\", \"flex\")\n                .css(\"justify-content\", \"space-around\")\n                .css(\"align-items\", \"center\")\n                .css(\"height\", \"100%\")\n                .css(\"font-size\", \"500%\")\n                .append($(\"<span>\").addClass(entity.getIcon()))\n        );\n    }\n\n    if (entity instanceof FNote) {\n        $renderedContent.addClass(entity.getCssClass());\n    }\n\n    return {\n        $renderedContent,\n        type\n    };\n}\n\n/** @param {FNote} note */\nasync function renderText(note, $renderedContent) {\n    // entity must be FNote\n    const blob = await note.getBlob();\n\n    if (!utils.isHtmlEmpty(blob.content)) {\n        $renderedContent.append($('<div class=\"ck-content\">').html(blob.content));\n\n        if ($renderedContent.find('span.math-tex').length > 0) {\n            await libraryLoader.requireLibrary(libraryLoader.KATEX);\n\n            renderMathInElement($renderedContent[0], {trust: true});\n        }\n\n        const getNoteIdFromLink = el => treeService.getNoteIdFromUrl($(el).attr('href'));\n        const referenceLinks = $renderedContent.find(\"a.reference-link\");\n        const noteIdsToPrefetch = referenceLinks.map(el => getNoteIdFromLink(el));\n        await froca.getNotes(noteIdsToPrefetch);\n\n        for (const el of referenceLinks) {\n            await linkService.loadReferenceLinkTitle($(el));\n        }\n    } else {\n        await renderChildrenList($renderedContent, note);\n    }\n}\n\n/** @param {FNote} note */\nasync function renderCode(note, $renderedContent) {\n    const blob = await note.getBlob();\n\n    $renderedContent.append($(\"<pre>\").text(blob.content));\n}\n\nfunction renderImage(entity, $renderedContent, options = {}) {\n    const encodedTitle = encodeURIComponent(entity.title);\n\n    let url;\n\n    if (entity instanceof FNote) {\n        url = `api/images/${entity.noteId}/${encodedTitle}?${Math.random()}`;\n    } else if (entity instanceof FAttachment) {\n        url = `api/attachments/${entity.attachmentId}/image/${encodedTitle}?${entity.utcDateModified}\">`;\n    }\n\n    $renderedContent // styles needed for the zoom to work well\n        .css('display', 'flex')\n        .css('align-items', 'center')\n        .css('justify-content', 'center');\n\n    const $img = $(\"<img>\")\n        .attr(\"src\", url)\n        .attr(\"id\", \"attachment-image-\" + idCounter++)\n        .css(\"max-width\", \"100%\");\n\n    $renderedContent.append($img);\n\n    if (options.imageHasZoom) {\n        libraryLoader.requireLibrary(libraryLoader.WHEEL_ZOOM).then(() => {\n            WZoom.create(`#${$img.attr(\"id\")}`, {\n                maxScale: 50,\n                speed: 1.3,\n                zoomOnClick: false\n            });\n        });\n    }\n}\n\nfunction renderFile(entity, type, $renderedContent) {\n    let entityType, entityId;\n\n    if (entity instanceof FNote) {\n        entityType = 'notes';\n        entityId = entity.noteId;\n    } else if (entity instanceof FAttachment) {\n        entityType = 'attachments';\n        entityId = entity.attachmentId;\n    } else {\n        throw new Error(`Can't recognize entity type of '${entity}'`);\n    }\n\n    const $content = $('<div style=\"display: flex; flex-direction: column; height: 100%;\">');\n\n    if (type === 'pdf') {\n        const $pdfPreview = $('<iframe class=\"pdf-preview\" style=\"width: 100%; flex-grow: 100;\"></iframe>');\n        $pdfPreview.attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open`));\n\n        $content.append($pdfPreview);\n    } else if (type === 'audio') {\n        const $audioPreview = $('<audio controls></audio>')\n            .attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open-partial`))\n            .attr(\"type\", entity.mime)\n            .css(\"width\", \"100%\");\n\n        $content.append($audioPreview);\n    } else if (type === 'video') {\n        const $videoPreview = $('<video controls></video>')\n            .attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open-partial`))\n            .attr(\"type\", entity.mime)\n            .css(\"width\", \"100%\");\n\n        $content.append($videoPreview);\n    }\n\n    if (entityType === 'notes') {\n        // TODO: we should make this available also for attachments, but there's a problem with \"Open externally\" support\n        //       in attachment list\n        const $downloadButton = $('<button class=\"file-download btn btn-primary\" type=\"button\">下载</button>');\n        const $openButton = $('<button class=\"file-open btn btn-primary\" type=\"button\">打开</button>');\n\n        $downloadButton.on('click', () => openService.downloadFileNote(entity.noteId));\n        $openButton.on('click', () => openService.openNoteExternally(entity.noteId, entity.mime));\n        // open doesn't work for protected notes since it works through a browser which isn't in protected session\n        $openButton.toggle(!entity.isProtected);\n\n        $content.append(\n            $('<div style=\"display: flex; justify-content: space-evenly; margin-top: 5px;\">')\n                .append($downloadButton)\n                .append($openButton)\n        );\n    }\n\n    $renderedContent.append($content);\n}\n\nasync function renderMermaid(note, $renderedContent) {\n    await libraryLoader.requireLibrary(libraryLoader.MERMAID);\n\n    const blob = await note.getBlob();\n    const content = blob.content || \"\";\n\n    $renderedContent\n        .css(\"display\", \"flex\")\n        .css(\"justify-content\", \"space-around\");\n\n    const documentStyle = window.getComputedStyle(document.documentElement);\n    const mermaidTheme = documentStyle.getPropertyValue('--mermaid-theme');\n\n    mermaid.mermaidAPI.initialize({startOnLoad: false, theme: mermaidTheme.trim(), securityLevel: 'antiscript'});\n\n    try {\n        const {svg} = await mermaid.mermaidAPI.render(\"in-mermaid-graph-\" + idCounter++, content);\n\n        $renderedContent.append($(svg));\n    } catch (e) {\n        const $error = $(\"<p>图表无法显示.</p>\");\n\n        $renderedContent.append($error);\n    }\n}\n\n/**\n * @param {jQuery} $renderedContent\n * @param {FNote} note\n * @returns {Promise<void>}\n */\nasync function renderChildrenList($renderedContent, note) {\n    $renderedContent.css(\"padding\", \"10px\");\n    $renderedContent.addClass(\"text-with-ellipsis\");\n\n    let childNoteIds = note.getChildNoteIds();\n\n    if (childNoteIds.length > 10) {\n        childNoteIds = childNoteIds.slice(0, 10);\n    }\n\n    // just load the first 10 child notes\n    const childNotes = await froca.getNotes(childNoteIds);\n\n    for (const childNote of childNotes) {\n        $renderedContent.append(await linkService.createLink(`${note.noteId}/${childNote.noteId}`, {\n            showTooltip: false,\n            showNoteIcon: true\n        }));\n\n        $renderedContent.append(\"<br>\");\n    }\n}\n\nfunction getRenderingType(entity) {\n    let type = entity.type || entity.role;\n    const mime = entity.mime;\n\n    if (type === 'file' && mime === 'application/pdf') {\n        type = 'pdf';\n    } else if (type === 'file' && mime.startsWith('audio/')) {\n        type = 'audio';\n    } else if (type === 'file' && mime.startsWith('video/')) {\n        type = 'video';\n    }\n\n    if (entity.isProtected) {\n        if (protectedSessionHolder.isProtectedSessionAvailable()) {\n            protectedSessionHolder.touchProtectedSession();\n        }\n        else {\n            type = 'protectedSession';\n        }\n    }\n\n    return type;\n}\n\nexport default {\n    getRenderedContent\n};\n","import froca from \"./froca.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\n\n/** @returns {FNote} */\nasync function getInboxNote() {\n    const note = await server.get(`special-notes/inbox/${dayjs().format(\"YYYY-MM-DD\")}`, \"date-note\");\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getTodayNote() {\n    return await getDayNote(dayjs().format(\"YYYY-MM-DD\"));\n}\n\n/** @returns {FNote} */\nasync function getDayNote(date) {\n    const note = await server.get(`special-notes/days/${date}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getWeekNote(date) {\n    const note = await server.get(`special-notes/weeks/${date}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getMonthNote(month) {\n    const note = await server.get(`special-notes/months/${month}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getYearNote(year) {\n    const note = await server.get(`special-notes/years/${year}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function createSqlConsole() {\n    const note = await server.post('special-notes/sql-console');\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function createSearchNote(opts = {}) {\n    const note = await server.post('special-notes/search-note', opts);\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\nexport default {\n    getInboxNote,\n    getTodayNote,\n    getDayNote,\n    getWeekNote,\n    getMonthNote,\n    getYearNote,\n    createSqlConsole,\n    createSearchNote\n}\n","import appContext from \"../components/app_context.js\";\n\nasync function info(message) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showInfoDialog\", {message, callback: res}));\n}\n\nasync function confirm(message) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showConfirmDialog\", {\n            message,\n            callback: x => res(x.confirmed)\n        }));\n}\n\nasync function confirmDeleteNoteBoxWithNote(title) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showConfirmDeleteNoteBoxWithNoteDialog\", {title, callback: res}));\n}\n\nasync function prompt(props) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showPromptDialog\", {...props, callback: res}));\n}\n\nexport default {\n    info,\n    confirm,\n    confirmDeleteNoteBoxWithNote,\n    prompt\n};\n","export default class FBlob {\n    constructor(row) {\n        /** @type {string} */\n        this.blobId = row.blobId;\n\n        /**\n         * can either contain the whole content (in e.g. string notes), only part (large text notes) or nothing at all (binary notes, images)\n         * @type {string}\n         */\n        this.content = row.content;\n        this.contentLength = row.contentLength;\n\n        /** @type {string} */\n        this.dateModified = row.dateModified;\n        /** @type {string} */\n        this.utcDateModified = row.utcDateModified;\n    }\n\n    /**\n     * @returns {*}\n     * @throws Error in case of invalid JSON */\n    getJsonContent() {\n        if (!this.content || !this.content.trim()) {\n            return null;\n        }\n\n        return JSON.parse(this.content);\n    }\n\n    /** @returns {*|null} valid object or null if the content cannot be parsed as JSON */\n    getJsonContentSafely() {\n        try {\n            return this.getJsonContent();\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n","import FBranch from \"../entities/fbranch.js\";\nimport FNote from \"../entities/fnote.js\";\nimport FAttribute from \"../entities/fattribute.js\";\nimport server from \"./server.js\";\nimport appContext from \"../components/app_context.js\";\nimport FBlob from \"../entities/fblob.js\";\nimport FAttachment from \"../entities/fattachment.js\";\n\n/**\n * Froca (FROntend CAche) keeps a read only cache of note tree structure in frontend's memory.\n * - notes are loaded lazily when unknown noteId is requested\n * - when note is loaded, all its parent and child branches are loaded as well. For a branch to be used, it's not must be loaded before\n * - deleted notes are present in the cache as well, but they don't have any branches. As a result check for deleted branch is done by presence check - if the branch is not there even though the corresponding note has been loaded, we can infer it is deleted.\n *\n * Note and branch deletions are corner cases and usually not needed.\n *\n * Backend has a similar cache called Becca\n */\nclass Froca {\n    constructor() {\n        this.initializedPromise = this.loadInitialTree();\n    }\n\n    async loadInitialTree() {\n        const resp = await server.get('tree');\n\n        // clear the cache only directly before adding new content which is important for e.g., switching to protected session\n\n        /** @type {Object.<string, FNote>} */\n        this.notes = {};\n\n        /** @type {Object.<string, FBranch>} */\n        this.branches = {};\n\n        /** @type {Object.<string, FAttribute>} */\n        this.attributes = {};\n\n        /** @type {Object.<string, FAttachment>} */\n        this.attachments = {};\n\n        /** @type {Object.<string, Promise<FBlob>>} */\n        this.blobPromises = {};\n\n        this.addResp(resp);\n    }\n\n    async loadSubTree(subTreeNoteId) {\n        const resp = await server.get(`tree?subTreeNoteId=${subTreeNoteId}`);\n\n        this.addResp(resp);\n\n        return this.notes[subTreeNoteId];\n    }\n\n    addResp(resp) {\n        const noteRows = resp.notes;\n        const branchRows = resp.branches;\n        const attributeRows = resp.attributes;\n\n        const noteIdsToSort = new Set();\n\n        for (const noteRow of noteRows) {\n            const {noteId} = noteRow;\n\n            let note = this.notes[noteId];\n\n            if (note) {\n                note.update(noteRow);\n\n                // search note doesn't have child branches in the database and all the children are virtual branches\n                if (note.type !== 'search') {\n                    for (const childNoteId of note.children) {\n                        const childNote = this.notes[childNoteId];\n\n                        if (childNote) {\n                            childNote.parents = childNote.parents.filter(p => p !== noteId);\n\n                            delete this.branches[childNote.parentToBranch[noteId]];\n                            delete childNote.parentToBranch[noteId];\n                        }\n                    }\n\n                    note.children = [];\n                    note.childToBranch = {};\n                }\n\n                // we want to remove all \"real\" branches (represented in the database) since those will be created\n                // from branches argument but want to preserve all virtual ones from saved search\n                note.parents = note.parents.filter(parentNoteId => {\n                    const parentNote = this.notes[parentNoteId];\n                    const branch = this.branches[parentNote.childToBranch[noteId]];\n\n                    if (!parentNote || !branch) {\n                        return false;\n                    }\n\n                    if (branch.fromSearchNote) {\n                        return true;\n                    }\n\n                    parentNote.children = parentNote.children.filter(p => p !== noteId);\n\n                    delete this.branches[parentNote.childToBranch[noteId]];\n                    delete parentNote.childToBranch[noteId];\n\n                    return false;\n                });\n            }\n            else {\n                this.notes[noteId] = new FNote(this, noteRow);\n            }\n        }\n\n        for (const branchRow of branchRows) {\n            const branch = new FBranch(this, branchRow);\n\n            this.branches[branch.branchId] = branch;\n\n            const childNote = this.notes[branch.noteId];\n\n            if (childNote) {\n                childNote.addParent(branch.parentNoteId, branch.branchId, false);\n            }\n\n            const parentNote = this.notes[branch.parentNoteId];\n\n            if (parentNote) {\n                parentNote.addChild(branch.noteId, branch.branchId, false);\n\n                noteIdsToSort.add(parentNote.noteId);\n            }\n        }\n\n        for (const attributeRow of attributeRows) {\n            const {attributeId} = attributeRow;\n\n            this.attributes[attributeId] = new FAttribute(this, attributeRow);\n\n            const note = this.notes[attributeRow.noteId];\n\n            if (note && !note.attributes.includes(attributeId)) {\n                note.attributes.push(attributeId);\n            }\n\n            if (attributeRow.type === 'relation') {\n                const targetNote = this.notes[attributeRow.value];\n\n                if (targetNote) {\n                    if (!targetNote.targetRelations.includes(attributeId)) {\n                        targetNote.targetRelations.push(attributeId);\n                    }\n                }\n            }\n        }\n\n        // sort all of them at once, this avoids repeated sorts (#1480)\n        for (const noteId of noteIdsToSort) {\n            this.notes[noteId].sortChildren();\n            this.notes[noteId].sortParents();\n        }\n    }\n\n    async reloadNotes(noteIds) {\n        if (noteIds.length === 0) {\n            return;\n        }\n\n        noteIds = Array.from(new Set(noteIds)); // make noteIds unique\n\n        const resp = await server.post('tree/load', { noteIds });\n\n        this.addResp(resp);\n\n        appContext.triggerEvent('notesReloaded', {noteIds});\n    }\n\n    async loadSearchNote(noteId) {\n        const note = await this.getNote(noteId);\n\n        if (!note || note.type !== 'search') {\n            return;\n        }\n\n        const {searchResultNoteIds, highlightedTokens, error} = await server.get(`search-note/${note.noteId}`);\n\n        if (!Array.isArray(searchResultNoteIds)) {\n            throw new Error(`Search note '${note.noteId}' failed: ${searchResultNoteIds}`);\n        }\n\n        // reset all the virtual branches from old search results\n        if (note.noteId in froca.notes) {\n            froca.notes[note.noteId].children = [];\n            froca.notes[note.noteId].childToBranch = {};\n        }\n\n        const branches = [...note.getParentBranches(), ...note.getChildBranches()];\n\n        searchResultNoteIds.forEach((resultNoteId, index) => branches.push({\n            // branchId should be repeatable since sometimes we reload some notes without rerendering the tree\n            branchId: `virt-${note.noteId}-${resultNoteId}`,\n            noteId: resultNoteId,\n            parentNoteId: note.noteId,\n            notePosition: (index + 1) * 10,\n            fromSearchNote: true\n        }));\n\n        // update this note with standard (parent) branches + virtual (children) branches\n        this.addResp({\n            notes: [note],\n            branches,\n            attributes: []\n        });\n\n        froca.notes[note.noteId].searchResultsLoaded = true;\n        froca.notes[note.noteId].highlightedTokens = highlightedTokens;\n\n        return {error};\n    }\n\n    /** @returns {FNote[]} */\n    getNotesFromCache(noteIds, silentNotFoundError = false) {\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.trace(`Can't find note '${noteId}'`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @returns {Promise<FNote[]>} */\n    async getNotes(noteIds, silentNotFoundError = false) {\n        noteIds = Array.from(new Set(noteIds)); // make unique\n        const missingNoteIds = noteIds.filter(noteId => !this.notes[noteId]);\n\n        await this.reloadNotes(missingNoteIds);\n\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.trace(`Can't find note '${noteId}'`);\n\n                return null;\n            } else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @returns {Promise<boolean>} */\n    async noteExists(noteId) {\n        const notes = await this.getNotes([noteId], true);\n\n        return notes.length === 1;\n    }\n\n    /** @returns {Promise<FNote>} */\n    async getNote(noteId, silentNotFoundError = false) {\n        if (noteId === 'none') {\n            console.trace(`No 'none' note.`);\n            return null;\n        }\n        else if (!noteId) {\n            console.trace(`Falsy noteId '${noteId}', returning null.`);\n            return null;\n        }\n\n        return (await this.getNotes([noteId], silentNotFoundError))[0];\n    }\n\n    /** @returns {FNote|null} */\n    getNoteFromCache(noteId) {\n        if (!noteId) {\n            throw new Error(\"空 noteId\");\n        }\n\n        return this.notes[noteId];\n    }\n\n    /** @returns {FBranch[]} */\n    getBranches(branchIds, silentNotFoundError = false) {\n        return branchIds\n            .map(branchId => this.getBranch(branchId, silentNotFoundError))\n            .filter(b => !!b);\n    }\n\n    /** @returns {FBranch} */\n    getBranch(branchId, silentNotFoundError = false) {\n        if (!(branchId in this.branches)) {\n            if (!silentNotFoundError) {\n                logError(`Not existing branch '${branchId}'`);\n            }\n        }\n        else {\n            return this.branches[branchId];\n        }\n    }\n\n    async getBranchId(parentNoteId, childNoteId) {\n        if (childNoteId === 'root') {\n            return 'none_root';\n        }\n\n        const child = await this.getNote(childNoteId);\n\n        if (!child) {\n            logError(`Could not find branchId for parent '${parentNoteId}', child '${childNoteId}' since child does not exist`);\n\n            return null;\n        }\n\n        return child.parentToBranch[parentNoteId];\n    }\n\n    /** @returns {Promise<FAttachment>} */\n    async getAttachment(attachmentId, silentNotFoundError = false) {\n        const attachment = this.attachments[attachmentId];\n        if (attachment) {\n            return attachment;\n        }\n\n        // load all attachments for the given note even if one is requested, don't load one by one\n        let attachmentRows;\n        try {\n            attachmentRows = await server.getWithSilentNotFound(`attachments/${attachmentId}/all`);\n        }\n        catch (e) {\n            if (silentNotFoundError) {\n                logInfo(`Attachment '${attachmentId}' not found, but silentNotFoundError is enabled: ` + e.message);\n                return null;\n            } else {\n                throw e;\n            }\n        }\n\n        const attachments = this.processAttachmentRows(attachmentRows);\n\n        if (attachments.length) {\n            attachments[0].getNote().attachments = attachments;\n        }\n\n        return this.attachments[attachmentId];\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachmentsForNote(noteId) {\n        const attachmentRows = await server.get(`notes/${noteId}/attachments`);\n        return this.processAttachmentRows(attachmentRows);\n    }\n\n    /** @returns {FAttachment[]} */\n    processAttachmentRows(attachmentRows) {\n        return attachmentRows.map(attachmentRow => {\n            let attachment;\n\n            if (attachmentRow.attachmentId in this.attachments) {\n                attachment = this.attachments[attachmentRow.attachmentId];\n                attachment.update(attachmentRow);\n            } else {\n                attachment = new FAttachment(this, attachmentRow);\n                this.attachments[attachment.attachmentId] = attachment;\n            }\n\n            return attachment;\n        });\n    }\n\n    /** @returns {Promise<FBlob>} */\n    async getBlob(entityType, entityId) {\n        // I'm not sure why we're not using blobIds directly, it would save us this composite key ...\n        // perhaps one benefit is that we're always requesting the latest blob, not relying on perhaps faulty/slow\n        // websocket update?\n        const key = `${entityType}-${entityId}`;\n\n        if (!this.blobPromises[key]) {\n            this.blobPromises[key] = server.get(`${entityType}/${entityId}/blob`)\n                .then(row => new FBlob(row))\n                .catch(e => console.error(`Cannot get blob for ${entityType} '${entityId}'`, e));\n\n            // we don't want to keep large payloads forever in memory, so we clean that up quite quickly\n            // this cache is more meant to share the data between different components within one business transaction (e.g. loading of the note into the tab context and all the components)\n            // if the blob is updated within the cache lifetime, it should be invalidated by froca_updater\n            this.blobPromises[key].then(\n                () => setTimeout(() => this.blobPromises[key] = null, 1000)\n            );\n        }\n\n        return await this.blobPromises[key];\n    }\n}\n\nconst froca = new Froca();\n\nexport default froca;\n","import appContext from \"../components/app_context.js\";\nimport treeService from \"./tree.js\";\nimport dialogService from \"./dialog.js\";\nimport froca from \"./froca.js\";\n\nfunction getHoistedNoteId() {\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n\n    return activeNoteContext ? activeNoteContext.hoistedNoteId : 'root';\n}\n\nasync function unhoist() {\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n\n    if (activeNoteContext) {\n        await activeNoteContext.unhoist();\n    }\n}\n\nfunction isTopLevelNode(node) {\n    return isHoistedNode(node.getParent());\n}\n\nfunction isHoistedNode(node) {\n    // even though check for 'root' should not be necessary, we keep it just in case\n    return node.data.noteId === \"root\"\n        || node.data.noteId === getHoistedNoteId();\n}\n\nasync function isHoistedInHiddenSubtree() {\n    const hoistedNoteId = getHoistedNoteId();\n\n    if (hoistedNoteId === 'root') {\n        return false;\n    }\n\n    const hoistedNote = await froca.getNote(hoistedNoteId);\n    return hoistedNote.isHiddenCompletely();\n}\n\nasync function checkNoteAccess(notePath, noteContext) {\n    const resolvedNotePath = await treeService.resolveNotePath(notePath, noteContext.hoistedNoteId);\n\n    if (!resolvedNotePath) {\n        console.log(`Cannot activate '${notePath}'`);\n        return false;\n    }\n\n    const hoistedNoteId = noteContext.hoistedNoteId;\n\n    if (!resolvedNotePath.includes(hoistedNoteId) && !resolvedNotePath.includes('_hidden')) {\n        const requestedNote = await froca.getNote(treeService.getNoteIdFromUrl(resolvedNotePath));\n        const hoistedNote = await froca.getNote(hoistedNoteId);\n\n        if (!hoistedNote.hasAncestor('_hidden')\n            && !await dialogService.confirm(`Requested note '${requestedNote.title}' is outside of hoisted note '${hoistedNote.title}' subtree and you must unhoist to access the note. Do you want to proceed with unhoisting?`)) {\n            return false;\n        }\n\n        // unhoist so we can activate the note\n        await unhoist();\n    }\n\n    return true;\n}\n\nexport default {\n    getHoistedNoteId,\n    unhoist,\n    isTopLevelNode,\n    isHoistedNode,\n    checkNoteAccess,\n    isHoistedInHiddenSubtree\n}\n","import server from \"./server.js\";\nimport appContext from \"../components/app_context.js\";\nimport shortcutService from \"./shortcuts.js\";\n\nconst keyboardActionRepo = {};\n\nconst keyboardActionsLoaded = server.get('keyboard-actions').then(actions => {\n\tactions = actions.filter(a => !!a.actionName); // filter out separators\n\n\tfor (const action of actions) {\n\t\taction.effectiveShortcuts = action.effectiveShortcuts.filter(shortcut => !shortcut.startsWith(\"global:\"));\n\n\t\tkeyboardActionRepo[action.actionName] = action;\n\t}\n\n\treturn actions;\n});\n\nasync function getActions() {\n\treturn await keyboardActionsLoaded;\n}\n\nasync function getActionsForScope(scope) {\n\tconst actions = await keyboardActionsLoaded;\n\n\treturn actions.filter(action => action.scope === scope);\n}\n\nasync function setupActionsForElement(scope, $el, component) {\n\tconst actions = await getActionsForScope(scope);\n\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tshortcutService.bindElShortcut($el, shortcut, () => component.triggerCommand(action.actionName, {ntxId: appContext.tabManager.activeNtxId}));\n\t\t}\n\t}\n}\n\ngetActionsForScope(\"window\").then(actions => {\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tshortcutService.bindGlobalShortcut(shortcut, () => appContext.triggerCommand(action.actionName, {ntxId: appContext.tabManager.activeNtxId}));\n\t\t}\n\t}\n});\n\nasync function getAction(actionName, silent = false) {\n\tawait keyboardActionsLoaded;\n\n\tconst action = keyboardActionRepo[actionName];\n\n\tif (!action) {\n\t\tif (silent) {\n\t\t\tconsole.debug(`Cannot find action '${actionName}'`);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Cannot find action '${actionName}'`);\n\t\t}\n\t}\n\n\treturn action;\n}\n\nfunction updateDisplayedShortcuts($container) {\n\t$container.find('kbd[data-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst keyboardActions = action.effectiveShortcuts.join(', ');\n\n\t\t\tif (keyboardActions || $(el).text() !== \"not set\") {\n\t\t\t\t$(el).text(keyboardActions);\n\t\t\t}\n\t\t}\n\t});\n\n\t$container.find('[data-trigger-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-trigger-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst title = $(el).attr('title');\n\t\t\tconst shortcuts = action.effectiveShortcuts.join(', ');\n\n\t\t\tif (title?.includes(shortcuts)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newTitle = !title?.trim() ? shortcuts : `${title} (${shortcuts})`;\n\n\t\t\t$(el).attr('title', newTitle);\n\t\t}\n\t});\n}\n\nexport default {\n\tupdateDisplayedShortcuts,\n\tsetupActionsForElement,\n\tgetActions,\n\tgetActionsForScope\n};\n","const CKEDITOR = {\"js\": [\"libraries/ckeditor/ckeditor.js\"]};\n\nconst CODE_MIRROR = {\n    js: [\n        \"libraries/codemirror/codemirror.js\",\n        \"libraries/codemirror/addon/display/placeholder.js\",\n        \"libraries/codemirror/addon/edit/matchbrackets.js\",\n        \"libraries/codemirror/addon/edit/matchtags.js\",\n        \"libraries/codemirror/addon/fold/xml-fold.js\",\n        \"libraries/codemirror/addon/lint/lint.js\",\n        \"libraries/codemirror/addon/lint/eslint.js\",\n        \"libraries/codemirror/addon/mode/loadmode.js\",\n        \"libraries/codemirror/addon/mode/multiplex.js\",\n        \"libraries/codemirror/addon/mode/overlay.js\",\n        \"libraries/codemirror/addon/mode/simple.js\",\n        \"libraries/codemirror/addon/search/match-highlighter.js\",\n        \"libraries/codemirror/mode/meta.js\",\n        \"libraries/codemirror/keymap/vim.js\"\n    ],\n    css: [\n        \"libraries/codemirror/codemirror.css\",\n        \"libraries/codemirror/addon/lint/lint.css\"\n    ]\n};\n\nconst ESLINT = {js: [\"libraries/eslint.js\"]};\n\nconst RELATION_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"libraries/panzoom.js\"\n    ],\n    css: [\n        \"stylesheets/relation_map.css\"\n    ]\n};\n\nconst PRINT_THIS = {js: [\"libraries/printThis.js\"]};\n\nconst CALENDAR_WIDGET = {css: [\"stylesheets/calendar.css\"]};\n\nconst KATEX = {\n    js: [ \"node_modules/katex/dist/katex.min.js\",\n        \"node_modules/katex/dist/contrib/mhchem.min.js\",\n        \"node_modules/katex/dist/contrib/auto-render.min.js\" ],\n    css: [ \"node_modules/katex/dist/katex.min.css\" ]\n};\n\nconst WHEEL_ZOOM = {\n    js: [ \"libraries/wheel-zoom.min.js\"]\n};\n\nconst FORCE_GRAPH = {\n    js: [ \"libraries/force-graph.min.js\"]\n};\n\nconst MERMAID = {\n    js: [ \"libraries/mermaid.min.js\" ]\n}\n\nconst EXCALIDRAW = {\n    js: [\n        \"node_modules/react/umd/react.production.min.js\",\n        \"node_modules/react-dom/umd/react-dom.production.min.js\",\n        \"node_modules/@excalidraw/excalidraw/dist/excalidraw.production.min.js\",\n    ]\n};\n\nconst MARKJS = {\n    js: [\n        \"libraries/jquery.mark.es6.min.js\"\n    ]\n};\n\nasync function requireLibrary(library) {\n    if (library.css) {\n        library.css.map(cssUrl => requireCss(cssUrl));\n    }\n\n    if (library.js) {\n        for (const scriptUrl of library.js) {\n            await requireScript(scriptUrl);\n        }\n    }\n}\n\n// we save the promises in case of the same script being required concurrently multiple times\nconst loadedScriptPromises = {};\n\nasync function requireScript(url) {\n    url = `${window.glob.assetPath}/${url}`;\n\n    if (!loadedScriptPromises[url]) {\n        loadedScriptPromises[url] = $.ajax({\n            url: url,\n            dataType: \"script\",\n            cache: true\n        });\n    }\n\n    await loadedScriptPromises[url];\n}\n\nasync function requireCss(url, prependAssetPath = true) {\n    const cssLinks = Array\n        .from(document.querySelectorAll('link'))\n        .map(el => el.href);\n\n    if (!cssLinks.some(l => l.endsWith(url))) {\n        if (prependAssetPath) {\n            url = `${window.glob.assetPath}/${url}`;\n        }\n\n        $('head').append($('<link rel=\"stylesheet\" type=\"text/css\" />').attr('href', url));\n    }\n}\n\nexport default {\n    requireCss,\n    requireLibrary,\n    CKEDITOR,\n    CODE_MIRROR,\n    ESLINT,\n    RELATION_MAP,\n    PRINT_THIS,\n    CALENDAR_WIDGET,\n    KATEX,\n    WHEEL_ZOOM,\n    FORCE_GRAPH,\n    MERMAID,\n    EXCALIDRAW,\n    MARKJS\n}\n","import treeService from './tree.js';\nimport linkContextMenuService from \"../menus/link_context_menu.js\";\nimport appContext from \"../components/app_context.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\n\nfunction getNotePathFromUrl(url) {\n    const notePathMatch = /#(root[A-Za-z0-9_/]*)$/.exec(url);\n\n    return notePathMatch === null ? null : notePathMatch[1];\n}\n\nasync function getLinkIcon(noteId, viewMode) {\n    let icon;\n\n    if (viewMode === 'default') {\n        const note = await froca.getNote(noteId);\n\n        icon = note.getIcon();\n    } else if (viewMode === 'source') {\n        icon = 'bx bx-code-curly';\n    } else if (viewMode === 'attachments') {\n        icon = 'bx bx-file';\n    }\n    return icon;\n}\n\nasync function createLink(notePath, options = {}) {\n    if (!notePath || !notePath.trim()) {\n        logError(\"缺少笔记路径\");\n\n        return $(\"<span>\").text(\"[missing note]\");\n    }\n\n    if (!notePath.startsWith(\"root\")) {\n        // all note paths should start with \"root/\" (except for \"root\" itself)\n        // used, e.g., to find internal links\n        notePath = `root/${notePath}`;\n    }\n\n    const showTooltip = options.showTooltip === undefined ? true : options.showTooltip;\n    const showNotePath = options.showNotePath === undefined ? false : options.showNotePath;\n    const showNoteIcon = options.showNoteIcon === undefined ? false : options.showNoteIcon;\n    const referenceLink = options.referenceLink === undefined ? false : options.referenceLink;\n    const autoConvertToImage = options.autoConvertToImage === undefined ? false : options.autoConvertToImage;\n\n    const { noteId, parentNoteId } = treeService.getNoteIdAndParentIdFromUrl(notePath);\n    const viewScope = options.viewScope || {};\n    const viewMode = viewScope.viewMode || 'default';\n    let linkTitle = options.title;\n\n    if (!linkTitle) {\n        if (viewMode === 'attachments' && viewScope.attachmentId) {\n            const attachment = await froca.getAttachment(viewScope.attachmentId);\n\n            linkTitle = attachment ? attachment.title : '[missing attachment]';\n        } else {\n            linkTitle = await treeService.getNoteTitle(noteId, parentNoteId);\n        }\n    }\n\n    const note = await froca.getNote(noteId);\n\n    if (autoConvertToImage && ['image', 'canvas', 'mermaid'].includes(note.type) && viewMode === 'default') {\n        const encodedTitle = encodeURIComponent(linkTitle);\n\n        return $(\"<img>\")\n            .attr(\"src\", `api/images/${noteId}/${encodedTitle}?${Math.random()}`)\n            .attr(\"alt\", linkTitle);\n    }\n\n    const $container = $(\"<span>\");\n\n    if (showNoteIcon) {\n        let icon = await getLinkIcon(noteId, viewMode);\n\n        if (icon) {\n            $container\n                .append($(\"<span>\").addClass(`bx ${icon}`))\n                .append(\" \");\n        }\n    }\n\n    const hash = calculateHash({\n        notePath,\n        viewScope: viewScope\n    });\n\n    const $noteLink = $(\"<a>\", {\n        href: hash,\n        text: linkTitle\n    });\n\n    if (!showTooltip) {\n        $noteLink.addClass(\"no-tooltip-preview\");\n    }\n\n    if (referenceLink) {\n        $noteLink.addClass(\"reference-link\");\n    }\n\n    $container.append($noteLink);\n\n    if (showNotePath) {\n        const resolvedNotePathSegments = await treeService.resolveNotePathToSegments(notePath);\n\n        if (resolvedNotePathSegments) {\n            resolvedNotePathSegments.pop(); // remove last element\n\n            const parentNotePath = resolvedNotePathSegments.join(\"/\").trim();\n\n            if (parentNotePath) {\n                $container.append($(\"<small>\").text(` (${await treeService.getNotePathTitle(parentNotePath)})`));\n            }\n        }\n    }\n\n    return $container;\n}\n\nfunction calculateHash({notePath, ntxId, hoistedNoteId, viewScope = {}}) {\n    notePath = notePath || \"\";\n    const params = [\n        ntxId ? { ntxId: ntxId } : null,\n        (hoistedNoteId && hoistedNoteId !== 'root') ? { hoistedNoteId: hoistedNoteId } : null,\n        viewScope.viewMode && viewScope.viewMode !== 'default' ? { viewMode: viewScope.viewMode } : null,\n        viewScope.attachmentId ? { attachmentId: viewScope.attachmentId } : null\n    ].filter(p => !!p);\n\n    const paramStr = params.map(pair => {\n        const name = Object.keys(pair)[0];\n        const value = pair[name];\n\n        return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n    }).join(\"&\");\n\n    if (!notePath && !paramStr) {\n        return \"\";\n    }\n\n    let hash = `#${notePath}`;\n\n    if (paramStr) {\n        hash += `?${paramStr}`;\n    }\n\n    return hash;\n}\n\nfunction parseNavigationStateFromUrl(url) {\n    if (!url) {\n        return {};\n    }\n\n    const hashIdx = url.indexOf('#');\n    if (hashIdx === -1) {\n        return {};\n    }\n\n    const hash = url.substr(hashIdx + 1); // strip also the initial '#'\n    const [notePath, paramString] = hash.split(\"?\");\n\n    if (!notePath.match(/^[_a-z0-9]{4,}(\\/[_a-z0-9]{4,})*$/i)) {\n        return {};\n    }\n\n    const viewScope = {\n        viewMode: 'default'\n    };\n    let ntxId = null;\n    let hoistedNoteId = null;\n    let searchString = null;\n\n    if (paramString) {\n        for (const pair of paramString.split(\"&\")) {\n            let [name, value] = pair.split(\"=\");\n            name = decodeURIComponent(name);\n            value = decodeURIComponent(value);\n\n            if (name === 'ntxId') {\n                ntxId = value;\n            } else if (name === 'hoistedNoteId') {\n                hoistedNoteId = value;\n            } else if (name === 'searchString') {\n                searchString = value; // supports triggering search from URL, e.g. #?searchString=blabla\n            } else if (['viewMode', 'attachmentId'].includes(name)) {\n                viewScope[name] = value;\n            } else {\n                console.warn(`Unrecognized hash parameter '${name}'.`);\n            }\n        }\n    }\n\n    return {\n        notePath,\n        noteId: treeService.getNoteIdFromUrl(notePath),\n        ntxId,\n        hoistedNoteId,\n        viewScope,\n        searchString\n    };\n}\n\nfunction goToLink(evt) {\n    const $link = $(evt.target).closest(\"a,.block-link\");\n    const hrefLink = $link.attr('href') || $link.attr('data-href');\n\n    return goToLinkExt(evt, hrefLink, $link);\n}\n\nfunction goToLinkExt(evt, hrefLink, $link) {\n    if (hrefLink?.startsWith(\"data:\")) {\n        return true;\n    }\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    const {notePath, viewScope} = parseNavigationStateFromUrl(hrefLink);\n\n    const ctrlKey = utils.isCtrlKey(evt);\n    const isLeftClick = evt.which === 1;\n    const isMiddleClick = evt.which === 2;\n    const openInNewTab = (isLeftClick && ctrlKey) || isMiddleClick;\n\n    const leftClick = evt.which === 1;\n    const middleClick = evt.which === 2;\n\n    if (notePath) {\n        if (openInNewTab) {\n            appContext.tabManager.openTabWithNoteWithHoisting(notePath, {viewScope});\n        } else if (isLeftClick) {\n            const ntxId = $(evt.target).closest(\"[data-ntx-id]\").attr(\"data-ntx-id\");\n\n            const noteContext = ntxId\n                ? appContext.tabManager.getNoteContextById(ntxId)\n                : appContext.tabManager.getActiveContext();\n\n            noteContext.setNote(notePath, {viewScope}).then(() => {\n                if (noteContext !== appContext.tabManager.getActiveContext()) {\n                    appContext.tabManager.activateNoteContext(noteContext.ntxId);\n                }\n            });\n        }\n    } else if (hrefLink) {\n        const withinEditLink = $link?.hasClass(\"ck-link-actions__preview\");\n        const outsideOfCKEditor = !$link || $link.closest(\"[contenteditable]\").length === 0;\n\n        if (openInNewTab\n            || (withinEditLink && (leftClick || middleClick))\n            || (outsideOfCKEditor && (leftClick || middleClick))\n        ) {\n            if (hrefLink.toLowerCase().startsWith('http') || hrefLink.startsWith(\"api/\")) {\n                window.open(hrefLink, '_blank');\n            } else if (hrefLink.toLowerCase().startsWith('file:') && utils.isElectron()) {\n                const electron = utils.dynamicRequire('electron');\n\n                electron.shell.openPath(hrefLink);\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction linkContextMenu(e) {\n    const $link = $(e.target).closest(\"a\");\n    const url = $link.attr(\"href\") || $link.attr(\"data-href\");\n\n    const { notePath, viewScope } = parseNavigationStateFromUrl(url);\n\n    if (!notePath) {\n        return;\n    }\n\n    e.preventDefault();\n\n    linkContextMenuService.openContextMenu(notePath, e, viewScope, null);\n}\n\nasync function loadReferenceLinkTitle($el, href = null) {\n    const $link = $el[0].tagName === 'A' ? $el : $el.find(\"a\");\n\n    href = href || $link.attr(\"href\");\n    if (!href) {\n        console.warn(\"Empty URL for parsing: \" + $el[0].outerHTML);\n        return;\n    }\n\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    const note = await froca.getNote(noteId, true);\n\n    if (note) {\n        $el.addClass(note.getColorClass());\n    }\n\n    const title = await getReferenceLinkTitle(href);\n    $el.text(title);\n\n    if (note) {\n        const icon = await getLinkIcon(noteId, viewScope.viewMode);\n\n        $el.prepend($(\"<span>\").addClass(icon));\n    }\n}\n\nasync function getReferenceLinkTitle(href) {\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    if (!noteId) {\n        return \"[missing note]\";\n    }\n\n    const note = await froca.getNote(noteId);\n    if (!note) {\n        return \"[missing note]\";\n    }\n\n    if (viewScope?.viewMode === 'attachments' && viewScope?.attachmentId) {\n        const attachment = await note.getAttachmentById(viewScope.attachmentId);\n\n        return attachment ? attachment.title : \"[missing attachment]\";\n    } else {\n        return note.title;\n    }\n}\n\nfunction getReferenceLinkTitleSync(href) {\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    if (!noteId) {\n        return \"[missing note]\";\n    }\n\n    const note = froca.getNoteFromCache(noteId);\n    if (!note) {\n        return \"[missing note]\";\n    }\n\n    if (viewScope?.viewMode === 'attachments' && viewScope?.attachmentId) {\n        if (!note.attachments) {\n            return \"[loading title...]\";\n        }\n\n        const attachment = note.attachments.find(att => att.attachmentId === viewScope.attachmentId);\n\n        return attachment ? attachment.title : \"[missing attachment]\";\n    } else {\n        return note.title;\n    }\n}\n\n$(document).on('click', \"a\", goToLink);\n$(document).on('auxclick', \"a\", goToLink); // to handle the middle button\n$(document).on('contextmenu', 'a', linkContextMenu);\n$(document).on('dblclick', \"a\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const $link = $(e.target).closest(\"a\");\n\n    const address = $link.attr('href');\n\n    if (address && address.startsWith('http')) {\n        window.open(address, '_blank');\n    }\n});\n\n$(document).on('mousedown', 'a', e => {\n    if (e.which === 2) {\n        // prevent paste on middle click\n        // https://github.com/zadam/trilium/issues/2995\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/auxclick_event#preventing_default_actions\n        e.preventDefault();\n        return false;\n    }\n});\n\nexport default {\n    getNotePathFromUrl,\n    createLink,\n    goToLink,\n    goToLinkExt,\n    loadReferenceLinkTitle,\n    getReferenceLinkTitle,\n    getReferenceLinkTitleSync,\n    calculateHash,\n    parseNavigationStateFromUrl\n};\n","/**\n * The purpose of this class is to cache the list of attributes for notes.\n *\n * Cache invalidation granularity is global - whenever a write operation is detected to notes, branches or attributes,\n * we invalidate the whole cache. That's OK, since the purpose for this is to speed up batch read-only operations, such\n * as loading the tree which uses attributes heavily.\n */\nclass NoteAttributeCache {\n    constructor() {\n        /** @property {Object.<string, BAttribute[]>} */\n        this.attributes = {};\n    }\n\n    invalidate() {\n        this.attributes = {};\n    }\n}\n\nconst noteAttributeCache = new NoteAttributeCache();\n\nexport default noteAttributeCache;\n","import appContext from \"../components/app_context.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\nimport froca from \"./froca.js\";\nimport treeService from \"./tree.js\";\nimport toastService from \"./toast.js\";\n\nasync function createNote(parentNotePath, options = {}) {\n    options = Object.assign({\n        activate: true,\n        focus: 'title',\n        target: 'into'\n    }, options);\n\n    // if isProtected isn't available (user didn't enter password yet), then note is created as unencrypted,\n    // but this is quite weird since the user doesn't see WHERE the note is being created, so it shouldn't occur often\n    if (!options.isProtected || !protectedSessionHolder.isProtectedSessionAvailable()) {\n        options.isProtected = false;\n    }\n\n    if (appContext.tabManager.getActiveContextNoteType() !== 'text') {\n        options.saveSelection = false;\n    }\n\n    if (options.saveSelection) {\n        [options.title, options.content] = parseSelectedHtml(options.textEditor.getSelectedHtml());\n    }\n\n    const parentNoteId = treeService.getNoteIdFromUrl(parentNotePath);\n\n    if (options.type === 'mermaid' && !options.content) {\n        options.content = `graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;`\n    }\n\n    const {note, branch} = await server.post(`notes/${parentNoteId}/children?target=${options.target}&targetBranchId=${options.targetBranchId || \"\"}`, {\n        title: options.title,\n        content: options.content || \"\",\n        isProtected: options.isProtected,\n        type: options.type,\n        mime: options.mime,\n        templateNoteId: options.templateNoteId\n    });\n\n    if (options.saveSelection) {\n        // we remove the selection only after it was saved to server to make sure we don't lose anything\n        options.textEditor.removeSelection();\n    }\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    if (options.activate) {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n        await activeNoteContext.setNote(`${parentNotePath}/${note.noteId}`);\n\n        if (options.focus === 'title') {\n            appContext.triggerEvent('focusAndSelectTitle', {isNewNote: true});\n        }\n        else if (options.focus === 'content') {\n            appContext.triggerEvent('focusOnDetail', {ntxId: activeNoteContext.ntxId});\n        }\n    }\n\n    const noteEntity = await froca.getNote(note.noteId);\n    const branchEntity = froca.getBranch(branch.branchId);\n\n    return {\n        note: noteEntity,\n        branch: branchEntity\n    };\n}\n\nasync function chooseNoteType() {\n    return new Promise(res => {\n        appContext.triggerCommand(\"chooseNoteType\", {callback: res});\n    });\n}\n\nasync function createNoteWithTypePrompt(parentNotePath, options = {}) {\n    const {success, noteType, templateNoteId} = await chooseNoteType();\n\n    if (!success) {\n        return;\n    }\n\n    options.type = noteType;\n    options.templateNoteId = templateNoteId;\n\n    return await createNote(parentNotePath, options);\n}\n\n/* If the first element is heading, parse it out and use it as a new heading. */\nfunction parseSelectedHtml(selectedHtml) {\n    const dom = $.parseHTML(selectedHtml);\n\n    if (dom.length > 0 && dom[0].tagName && dom[0].tagName.match(/h[1-6]/i)) {\n        const title = $(dom[0]).text();\n        // remove the title from content (only first occurrence)\n        const content = selectedHtml.replace(dom[0].outerHTML, \"\");\n\n        return [title, content];\n    }\n    else {\n        return [null, selectedHtml];\n    }\n}\n\nasync function duplicateSubtree(noteId, parentNotePath) {\n    const parentNoteId = treeService.getNoteIdFromUrl(parentNotePath);\n    const {note} = await server.post(`notes/${noteId}/duplicate/${parentNoteId}`);\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n    activeNoteContext.setNote(`${parentNotePath}/${note.noteId}`);\n\n    const origNote = await froca.getNote(noteId);\n    toastService.showMessage(`笔记 \"${origNote.title}\" 已被复制`);\n}\n\nexport default {\n    createNote,\n    createNoteWithTypePrompt,\n    duplicateSubtree,\n    chooseNoteType\n};\n","import treeService from \"./tree.js\";\nimport linkService from \"./link.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport attributeRenderer from \"./attribute_renderer.js\";\nimport contentRenderer from \"./content_renderer.js\";\nimport appContext from \"../components/app_context.js\";\n\nfunction setupGlobalTooltip() {\n    $(document).on(\"mouseenter\", \"a\", mouseEnterHandler);\n\n    // close any note tooltip after click, this fixes the problem that sometimes tooltips remained on the screen\n    $(document).on(\"click\", e => {\n        if ($(e.target).closest(\".note-tooltip\").length) {\n            // click within the tooltip shouldn't close it\n            return;\n        }\n\n        $('.note-tooltip').remove();\n    });\n}\n\nfunction setupElementTooltip($el) {\n    $el.on('mouseenter', mouseEnterHandler);\n}\n\nasync function mouseEnterHandler() {\n    const $link = $(this);\n\n    if ($link.hasClass(\"no-tooltip-preview\") || $link.hasClass(\"disabled\")) {\n        return;\n    } else if ($link.closest(\".ck-link-actions\").length) {\n        // this is to avoid showing tooltip from inside the CKEditor link editor dialog\n        return;\n    } else if ($link.closest(\".note-tooltip\").length) {\n        // don't show tooltip for links within tooltip\n        return;\n    }\n\n    const url = $link.attr(\"href\") || $link.attr(\"data-href\");\n    const { notePath, noteId, viewScope } = linkService.parseNavigationStateFromUrl(url);\n\n    if (!notePath || viewScope.viewMode !== 'default') {\n        return;\n    }\n\n    const linkId = $link.attr(\"data-link-id\") || `link-${Math.floor(Math.random() * 1000000)}`;\n    $link.attr(\"data-link-id\", linkId);\n\n    if ($(`.${linkId}`).is(\":visible\")) {\n        // tooltip is already open for this link\n        return;\n    }\n\n    const note = await froca.getNote(noteId);\n\n    const [content] = await Promise.all([\n        renderTooltip(note),\n        // to reduce flicker due to accidental mouseover, cursor must stay for a bit over the link for tooltip to appear\n        new Promise(res => setTimeout(res, 500))\n    ]);\n\n    if (utils.isHtmlEmpty(content)) {\n        return;\n    }\n\n    const html = `<div class=\"note-tooltip-content\">${content}</div>`;\n    const tooltipClass = 'tooltip-' + Math.floor(Math.random() * 999_999_999);\n\n    // we need to check if we're still hovering over the element\n    // since the operation to get tooltip content was async, it is possible that\n    // we now create tooltip which won't close because it won't receive mouseleave event\n    if ($(this).filter(\":hover\").length > 0) {\n        $(this).tooltip({\n            container: 'body',\n            // https://github.com/zadam/trilium/issues/2794 https://github.com/zadam/trilium/issues/2988\n            // with bottom this flickering happens a bit less\n            placement: 'bottom',\n            trigger: 'manual',\n            boundary: 'window',\n            title: html,\n            html: true,\n            template: `<div class=\"tooltip note-tooltip ${tooltipClass}\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>`,\n            sanitize: false,\n            customClass: linkId\n        });\n\n        $(this).tooltip('show');\n\n        // the purpose of the code below is to:\n        // - allow user to go from hovering the link to hovering the tooltip to be able to scroll,\n        //   click on links within tooltip etc. without tooltip disappearing\n        // - once the user moves the cursor away from both link and the tooltip, hide the tooltip\n        const checkTooltip = () => {\n            if (!$(`.${tooltipClass}`).is(':visible')) {\n                console.log(\"Not visible anymore\");\n\n                return;\n            }\n\n            if (!$(this).filter(\":hover\").length && !$(`.${linkId}:hover`).length) {\n                // cursor is neither over the link nor over the tooltip, user likely is not interested\n                $(this).tooltip('dispose');\n            } else {\n                setTimeout(checkTooltip, 1000);\n            }\n        }\n\n        setTimeout(checkTooltip, 1000);\n    }\n}\n\nasync function renderTooltip(note) {\n    if (!note) {\n        return '<div>笔记已被删除.</div>';\n    }\n\n    const hoistedNoteId = appContext.tabManager.getActiveContext()?.hoistedNoteId;\n    const bestNotePath = note.getBestNotePathString(hoistedNoteId);\n\n    if (!bestNotePath) {\n        return;\n    }\n\n    let content = `<h5 class=\"note-tooltip-title\">${(await treeService.getNoteTitleWithPathAsSuffix(bestNotePath)).prop('outerHTML')}</h5>`;\n\n    const {$renderedAttributes} = await attributeRenderer.renderNormalAttributes(note);\n\n    const {$renderedContent} = await contentRenderer.getRenderedContent(note, {\n        tooltip: true,\n        trim: true\n    });\n\n    content = `${content}<div class=\"note-tooltip-attributes\">${$renderedAttributes[0].outerHTML}</div>${$renderedContent[0].outerHTML}`;\n\n    return content;\n}\n\nexport default {\n    setupGlobalTooltip,\n    setupElementTooltip\n}\n","import utils from \"./utils.js\";\nimport server from \"./server.js\";\n\nfunction checkType(type) {\n    if (type !== 'notes' && type !== 'attachments') {\n        throw new Error(`Unrecognized type '${type}', should be 'notes' or 'attachments'`);\n    }\n}\n\nfunction getFileUrl(type, noteId) {\n    checkType(type);\n\n    return getUrlForDownload(`api/${type}/${noteId}/download`);\n}\n\nfunction getOpenFileUrl(type, noteId) {\n    checkType(type);\n\n    return getUrlForDownload(`api/${type}/${noteId}/open`);\n}\n\nfunction download(url) {\n    if (utils.isElectron()) {\n        const remote = utils.dynamicRequire('@electron/remote');\n\n        remote.getCurrentWebContents().downloadURL(url);\n    } else {\n        window.location.href = url;\n    }\n}\n\nfunction downloadFileNote(noteId) {\n    const url = `${getFileUrl('notes', noteId)}?${Date.now()}`; // don't use cache\n\n    download(url);\n}\n\nfunction downloadAttachment(attachmentId) {\n    const url = `${getFileUrl('attachments', attachmentId)}?${Date.now()}`; // don't use cache\n\n    download(url);\n}\n\nasync function openCustom(type, entityId, mime) {\n    checkType(type);\n    if (!utils.isElectron() || utils.isMac()) {\n        return;\n    }\n\n    const resp = await server.post(`${type}/${entityId}/save-to-tmp-dir`);\n    let filePath = resp.tmpFilePath;\n    const {exec} = utils.dynamicRequire('child_process');\n    const platform = process.platform;\n\n    if (platform === 'linux') {\n        // we don't know which terminal is available, try in succession\n        const terminals = ['x-terminal-emulator', 'gnome-terminal', 'konsole', 'xterm', 'xfce4-terminal', 'mate-terminal', 'rxvt', 'terminator', 'terminology'];\n        const openFileWithTerminal = (terminal) => {\n            const command = `${terminal} -e 'mimeopen -d \"${filePath}\"'`;\n            console.log(`Open Note custom: ${command} `);\n            exec(command, (error, stdout, stderr) => {\n                if (error) {\n                    console.error(`Open Note custom: Failed to open file with ${terminal}: ${error}`);\n                    searchTerminal(terminals.indexOf(terminal) + 1);\n                } else {\n                    console.log(`Open Note custom: File opened with ${terminal}: ${stdout}`);\n                }\n            });\n        };\n\n        const searchTerminal = (index) => {\n            const terminal = terminals[index];\n            if (!terminal) {\n                console.error('Open Note custom: No terminal found!');\n                open(getFileUrl(entityId), {url: true});\n                return;\n            }\n            exec(`which ${terminal}`, (error, stdout, stderr) => {\n                if (stdout.trim()) {\n                    openFileWithTerminal(terminal);\n                } else {\n                    searchTerminal(index + 1);\n                }\n            });\n        };\n        searchTerminal(0);\n    } else if (platform === 'win32') {\n        if (filePath.indexOf(\"/\") !== -1) {\n            // Note that the path separator must be \\ instead of /\n            filePath = filePath.replace(/\\//g, \"\\\\\");\n        }\n        const command = `rundll32.exe shell32.dll,OpenAs_RunDLL ` + filePath;\n        exec(command, (err, stdout, stderr) => {\n            if (err) {\n                console.error(\"Open Note custom: \", err);\n                open(getFileUrl(entityId), {url: true});\n                return;\n            }\n        });\n    } else {\n        console.log('Currently \"Open Note custom\" only supports linux and windows systems');\n        open(getFileUrl(entityId), {url: true});\n    }\n}\n\nconst openNoteCustom = async (noteId, mime) => await openCustom('notes', noteId, mime);\nconst openAttachmentCustom = async (attachmentId, mime) => await openCustom('attachments', attachmentId, mime);\n\n\nfunction downloadRevision(noteId, revisionId) {\n    const url = getUrlForDownload(`api/revisions/${revisionId}/download`);\n\n    download(url);\n}\n\n/**\n * @param url - should be without initial slash!!!\n */\nfunction getUrlForDownload(url) {\n    if (utils.isElectron()) {\n        // electron needs absolute URL, so we extract current host, port, protocol\n        return `${getHost()}/${url}`;\n    }\n    else {\n        // web server can be deployed on subdomain, so we need to use a relative path\n        return url;\n    }\n}\n\nfunction canOpenInBrowser(mime) {\n    return mime === \"application/pdf\"\n        || mime.startsWith(\"image\")\n        || mime.startsWith(\"audio\")\n        || mime.startsWith(\"video\");\n}\n\nasync function openExternally(type, entityId, mime) {\n    checkType(type);\n\n    if (utils.isElectron()) {\n        const resp = await server.post(`${type}/${entityId}/save-to-tmp-dir`);\n\n        const electron = utils.dynamicRequire('electron');\n        const res = await electron.shell.openPath(resp.tmpFilePath);\n\n        if (res) {\n            // fallback in case there's no default application for this file\n            window.open(getFileUrl(type, entityId));\n        }\n    }\n    else {\n        // allow browser to handle opening common file\n        if (canOpenInBrowser(mime)) {\n            window.open(getOpenFileUrl(type, entityId));\n        } else {\n            window.location.href = getFileUrl(type, entityId);\n        }\n    }\n}\n\nconst openNoteExternally = async (noteId, mime) => await openExternally('notes', noteId, mime);\nconst openAttachmentExternally = async (attachmentId, mime) => await openExternally('attachments', attachmentId, mime);\n\nfunction getHost() {\n    const url = new URL(window.location.href);\n    return `${url.protocol}//${url.hostname}:${url.port}`;\n}\n\nexport default {\n    download,\n    downloadFileNote,\n    downloadRevision,\n    downloadAttachment,\n    getUrlForDownload,\n    openNoteExternally,\n    openAttachmentExternally,\n    openNoteCustom,\n    openAttachmentCustom,\n}\n","import server from \"./server.js\";\n\nclass Options {\n    constructor() {\n        this.initializedPromise = server.get('options').then(data => this.load(data));\n    }\n\n    load(arr) {\n        this.arr = arr;\n    }\n\n    get(key) {\n        return this.arr[key];\n    }\n\n    getNames() {\n        return Object.keys(this.arr);\n    }\n\n    getJson(key) {\n        try {\n            return JSON.parse(this.arr[key]);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    getInt(key) {\n        return parseInt(this.arr[key]);\n    }\n\n    getFloat(key) {\n        return parseFloat(this.arr[key]);\n    }\n\n    is(key) {\n        return this.arr[key] === 'true';\n    }\n\n    set(key, value) {\n        this.arr[key] = value;\n    }\n\n    async save(key, value) {\n        this.set(key, value);\n\n        const payload = {};\n        payload[key] = value;\n\n        await server.put(`options`, payload);\n    }\n\n    async toggle(key) {\n        await this.save(key, (!this.is(key)).toString());\n    }\n}\n\nconst options = new Options();\n\nexport default options;\n","function parse(value) {\n    const tokens = value.split(',').map(t => t.trim());\n    const defObj = {};\n\n    for (const token of tokens) {\n        if (token === 'promoted') {\n            defObj.isPromoted = true;\n        }\n        else if (['text', 'number', 'boolean', 'date', 'datetime', 'url'].includes(token)) {\n            defObj.labelType = token;\n        }\n        else if (['single', 'multi'].includes(token)) {\n            defObj.multiplicity = token;\n        }\n        else if (token.startsWith('precision')) {\n            const chunks = token.split('=');\n\n            defObj.numberPrecision = parseInt(chunks[1]);\n        }\n        else if (token.startsWith('alias')) {\n            const chunks = token.split('=');\n\n            defObj.promotedAlias = chunks[1];\n        }\n        else if (token.startsWith('inverse')) {\n            const chunks = token.split('=');\n\n            defObj.inverseRelation = chunks[1];\n        }\n        else {\n            console.log(\"Unrecognized attribute definition token:\", token);\n        }\n    }\n\n    return defObj;\n}\n\nexport default {\n    parse\n};\n","import server from './server.js';\nimport protectedSessionHolder from './protected_session_holder.js';\nimport toastService from \"./toast.js\";\nimport ws from \"./ws.js\";\nimport appContext from \"../components/app_context.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport options from \"./options.js\";\n\nlet protectedSessionDeferred = null;\n\nasync function leaveProtectedSession() {\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        await protectedSessionHolder.resetProtectedSession();\n    }\n}\n\n/** returned promise resolves with true if new protected session was established, false if no action was necessary */\nfunction enterProtectedSession() {\n    const dfd = $.Deferred();\n\n    if (!options.is(\"isPasswordSet\")) {\n        appContext.triggerCommand(\"showPasswordNotSet\");\n        return dfd;\n    }\n\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        dfd.resolve(false);\n    }\n    else {\n        // using deferred instead of promise because it allows resolving from the outside\n        protectedSessionDeferred = dfd;\n\n        appContext.triggerCommand(\"showProtectedSessionPasswordDialog\");\n    }\n\n    return dfd.promise();\n}\n\nasync function reloadData() {\n    const allNoteIds = Object.keys(froca.notes);\n\n    await froca.loadInitialTree();\n\n    // make sure that all notes used in the application are loaded, including the ones not shown in the tree\n    await froca.reloadNotes(allNoteIds, true);\n}\n\nasync function setupProtectedSession(password) {\n    const response = await server.post('login/protected', { password: password });\n\n    if (!response.success) {\n        toastService.showError(\"密码错误.\", 3000);\n        return;\n    }\n\n    protectedSessionHolder.enableProtectedSession();\n}\n\nws.subscribeToMessages(async message => {\n    if (message.type === 'protectedSessionLogin') {\n        await reloadData();\n\n        await appContext.triggerEvent('frocaReloaded');\n\n        appContext.triggerEvent('protectedSessionStarted');\n\n        appContext.triggerCommand(\"closeProtectedSessionPasswordDialog\");\n\n        if (protectedSessionDeferred !== null) {\n            protectedSessionDeferred.resolve(true);\n            protectedSessionDeferred = null;\n        }\n\n        toastService.showMessage(\"受保护的会话已启动.\");\n    }\n    else if (message.type === 'protectedSessionLogout') {\n        utils.reloadFrontendApp(`Protected session logout`);\n    }\n});\n\nasync function protectNote(noteId, protect, includingSubtree) {\n    await enterProtectedSession();\n\n    await server.put(`notes/${noteId}/protect/${protect ? 1 : 0}?subtree=${includingSubtree ? 1 : 0}`);\n}\n\nfunction makeToast(message, protectingLabel, text) {\n    return {\n        id: message.taskId,\n        title: `${protectingLabel} status`,\n        message: text,\n        icon: message.data.protect ? \"check-shield\" : \"shield\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'protectNotes') {\n        return;\n    }\n\n    const protectingLabel = message.data.protect ? \"保护\" : \"取消保护\";\n\n    if (message.type === 'taskError') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'taskProgressCount') {\n        toastService.showPersistent(makeToast(message, protectingLabel,`${protectingLabel} in progress: ${message.progressCount}`));\n    } else if (message.type === 'taskSucceeded') {\n        const toast = makeToast(message, protectingLabel, `${protectingLabel} finished successfully.`);\n        toast.closeAfter = 3000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nexport default {\n    protectNote,\n    enterProtectedSession,\n    leaveProtectedSession,\n    setupProtectedSession\n};\n","import server from \"./server.js\";\n\nfunction enableProtectedSession() {\n    glob.isProtectedSessionAvailable = true;\n\n    touchProtectedSession();\n}\n\nasync function resetProtectedSession() {\n    await server.post(\"logout/protected\");\n}\n\nfunction isProtectedSessionAvailable() {\n    return glob.isProtectedSessionAvailable;\n}\n\nasync function touchProtectedSession() {\n    if (isProtectedSessionAvailable()) {\n        await server.post(\"login/protected/touch\");\n    }\n}\n\nfunction touchProtectedSessionIfNecessary(note) {\n    if (note && note.isProtected && isProtectedSessionAvailable()) {\n        touchProtectedSession();\n    }\n}\n\nexport default {\n    enableProtectedSession,\n    resetProtectedSession,\n    isProtectedSessionAvailable,\n    touchProtectedSession,\n    touchProtectedSessionIfNecessary\n};\n","import server from \"./server.js\";\nimport bundleService from \"./bundle.js\";\n\nasync function render(note, $el) {\n    const relations = note.getRelations('renderNote');\n    const renderNoteIds = relations\n        .map(rel => rel.value)\n        .filter(noteId => noteId);\n\n    $el.empty().toggle(renderNoteIds.length > 0);\n\n    for (const renderNoteId of renderNoteIds) {\n        const bundle = await server.post(`script/bundle/${renderNoteId}`);\n\n        const $scriptContainer = $('<div>');\n        $el.append($scriptContainer);\n\n        $scriptContainer.append(bundle.html);\n\n        // async so that scripts cannot block trilium execution\n        bundleService.executeBundle(bundle, note, $scriptContainer);\n    }\n\n    return renderNoteIds.length > 0;\n}\n\nexport default {\n    render\n}\n","import server from './server.js';\nimport utils from './utils.js';\nimport toastService from './toast.js';\nimport linkService from './link.js';\nimport froca from './froca.js';\nimport noteTooltipService from './note_tooltip.js';\nimport protectedSessionService from './protected_session.js';\nimport dateNotesService from './date_notes.js';\nimport searchService from './search.js';\nimport RightPanelWidget from '../widgets/right_panel_widget.js';\nimport ws from \"./ws.js\";\nimport appContext from \"../components/app_context.js\";\nimport NoteContextAwareWidget from \"../widgets/note_context_aware_widget.js\";\nimport BasicWidget from \"../widgets/basic_widget.js\";\nimport SpacedUpdate from \"./spaced_update.js\";\nimport shortcutService from \"./shortcuts.js\";\nimport dialogService from \"./dialog.js\";\n\n\n/**\n * A whole number\n * @typedef {number} int\n */\n\n/**\n * An instance of the frontend api available globally.\n * @global\n * @var {FrontendScriptApi} api\n */\n\n/**\n * <p>This is the main frontend API interface for scripts. All the properties and methods are published in the \"api\" object\n * available in the JS frontend notes. You can use e.g. <code>api.showMessage(api.startNote.title);</code></p>\n *\n * @constructor\n */\nfunction FrontendScriptApi(startNote, currentNote, originEntity = null, $container = null) {\n    /**\n     * Container of all the rendered script content\n     * @type {jQuery}\n     * */\n    this.$container = $container;\n\n    /**\n     * Note where the script started executing, i.e., the (event) entrypoint of the current script execution.\n     * @type {FNote}\n     */\n    this.startNote = startNote;\n\n    /**\n     * Note where the script is currently executing, i.e. the note where the currently executing source code is written.\n     * @type {FNote}\n     */\n    this.currentNote = currentNote;\n\n    /**\n     * Entity whose event triggered this execution.\n     * @type {object|null}\n     */\n    this.originEntity = originEntity;\n\n    /**\n     * day.js library for date manipulation.\n     * See {@link https://day.js.org} for documentation\n     * @see https://day.js.org\n     * @type {dayjs}\n     */\n    this.dayjs = dayjs;\n\n    /** @type {RightPanelWidget} */\n    this.RightPanelWidget = RightPanelWidget;\n\n    /** @type {NoteContextAwareWidget} */\n    this.NoteContextAwareWidget = NoteContextAwareWidget;\n\n    /** @type {BasicWidget} */\n    this.BasicWidget = BasicWidget;\n\n    /**\n     * Activates note in the tree and in the note detail.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNote = async notePath => {\n        await appContext.tabManager.getActiveContext().setNote(notePath);\n    };\n\n    /**\n     * Activates newly created note. Compared to this.activateNote() also makes sure that frontend has been fully synced.\n     *\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNewNote = async notePath => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.getActiveContext().setNote(notePath);\n        await appContext.triggerEvent('focusAndSelectTitle');\n    };\n\n    /**\n     * Open a note in a new tab.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {boolean} activate - set to true to activate the new tab, false to stay on the current tab\n     * @returns {Promise<void>}\n     */\n    this.openTabWithNote = async (notePath, activate) => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.openTabWithNoteWithHoisting(notePath, { activate });\n\n        if (activate) {\n            await appContext.triggerEvent('focusAndSelectTitle');\n        }\n    };\n\n    /**\n     * Open a note in a new split.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {boolean} activate - set to true to activate the new split, false to stay on the current split\n     * @returns {Promise<void>}\n     */\n    this.openSplitWithNote = async (notePath, activate) => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        const subContexts = appContext.tabManager.getActiveContext().getSubContexts();\n        const {ntxId} = subContexts[subContexts.length - 1];\n\n        await appContext.triggerCommand(\"openNewNoteSplit\", {ntxId, notePath});\n\n        if (activate) {\n            await appContext.triggerEvent('focusAndSelectTitle');\n        }\n    };\n\n    /**\n     * Adds a new launcher to the launchbar. If the launcher (id) already exists, it will be updated.\n     *\n     * @method\n     * @deprecated you can now create/modify launchers in the top-left Menu -> Configure Launchbar\n     *             for special needs there's also backend API's createOrUpdateLauncher()\n     * @param {object} opts\n     * @param {string} opts.title\n     * @param {function} opts.action - callback handling the click on the button\n     * @param {string} [opts.id] - id of the button, used to identify the old instances of this button to be replaced\n     *                          ID is optional because of BC, but not specifying it is deprecated. ID can be alphanumeric only.\n     * @param {string} [opts.icon] - name of the boxicon to be used (e.g. \"time\" for \"bx-time\" icon)\n     * @param {string} [opts.shortcut] - keyboard shortcut for the button, e.g. \"alt+t\"\n     */\n    this.addButtonToToolbar = async opts => {\n        console.warn(\"api.addButtonToToolbar() has been deprecated since v0.58 and may be removed in the future. Use  Menu -> Configure Launchbar to create/update launchers instead.\");\n\n        const {action, ...reqBody} = opts;\n        reqBody.action = action.toString();\n\n        await server.put('special-notes/api-script-launcher', reqBody);\n    };\n\n    function prepareParams(params) {\n        if (!params) {\n            return params;\n        }\n\n        return params.map(p => {\n            if (typeof p === \"function\") {\n                return `!@#Function: ${p.toString()}`;\n            }\n            else {\n                return p;\n            }\n        });\n    }\n\n    /**\n     * @private\n     */\n    this.__runOnBackendInner = async (func, params, transactional) => {\n        if (typeof func === \"function\") {\n            func = func.toString();\n        }\n\n        const ret = await server.post('script/exec', {\n            script: func,\n            params: prepareParams(params),\n            startNoteId: startNote.noteId,\n            currentNoteId: currentNote.noteId,\n            originEntityName: \"notes\", // currently there's no other entity on the frontend which can trigger event\n            originEntityId: originEntity ? originEntity.noteId : null,\n            transactional\n        }, \"script\");\n\n        if (ret.success) {\n            await ws.waitForMaxKnownEntityChangeId();\n\n            return ret.executionResult;\n        } else {\n            throw new Error(`server error: ${ret.error}`);\n        }\n    }\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     * Please make sure that the supplied function is synchronous. Only sync functions will work correctly\n     * with transaction management. If you really know what you're doing, you can call api.runAsyncOnBackendWithManualTransactionHandling()\n     *\n     * @method\n     * @param {function|string} func - (synchronous) function to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be sent to backend\n     * @returns {Promise<*>} return value of the executed function on the backend\n     */\n    this.runOnBackend = async (func, params = []) => {\n        if (func?.constructor.name === \"AsyncFunction\" || func?.startsWith?.(\"async \")) {\n            toastService.showError(\"You're passing an async function to api.runOnBackend() which will likely not work as you intended. \"\n                + \"Either make the function synchronous (by removing 'async' keyword), or use api.runAsyncOnBackendWithManualTransactionHandling()\");\n        }\n\n        return await this.__runOnBackendInner(func, params, true);\n    };\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     * This function is meant for advanced needs where an async function is necessary.\n     * In this case, the automatic request-scoped transaction management is not applied,\n     * and you need to manually define transaction via api.transactional().\n     *\n     * If you have a synchronous function, please use api.runOnBackend().\n     *\n     * @method\n     * @param {function|string} func - (synchronous) function to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be sent to backend\n     * @returns {Promise<*>} return value of the executed function on the backend\n     */\n    this.runAsyncOnBackendWithManualTransactionHandling = async (func, params = []) => {\n        if (func?.constructor.name === \"Function\" || func?.startsWith?.(\"function\")) {\n            toastService.showError(\"You're passing a synchronous function to api.runAsyncOnBackendWithManualTransactionHandling(), \" +\n                \"while you should likely use api.runOnBackend() instead.\");\n        }\n\n        return await this.__runOnBackendInner(func, params, false);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"#dateModified =* MONTH AND #log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<FNote[]>}\n     */\n    this.searchForNotes = async searchString => {\n        return await searchService.searchForNotes(searchString);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"#dateModified =* MONTH AND #log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<FNote|null>}\n     */\n    this.searchForNote = async searchString => {\n        const notes = await this.searchForNotes(searchString);\n\n        return notes.length > 0 ? notes[0] : null;\n    };\n\n    /**\n     * Returns note by given noteId. If note is missing from the cache, it's loaded.\n     **\n     * @method\n     * @param {string} noteId\n     * @returns {Promise<FNote>}\n     */\n    this.getNote = async noteId => await froca.getNote(noteId);\n\n    /**\n     * Returns list of notes. If note is missing from the cache, it's loaded.\n     *\n     * This is often used to bulk-fill the cache with notes which would have to be picked one by one\n     * otherwise (by e.g. createLink())\n     *\n     * @method\n     * @param {string[]} noteIds\n     * @param {boolean} [silentNotFoundError] - don't report error if the note is not found\n     * @returns {Promise<FNote[]>}\n     */\n    this.getNotes = async (noteIds, silentNotFoundError = false) => await froca.getNotes(noteIds, silentNotFoundError);\n\n    /**\n     * Update frontend tree (note) cache from the backend.\n     *\n     * @method\n     * @param {string[]} noteIds\n     */\n    this.reloadNotes = async noteIds => await froca.reloadNotes(noteIds);\n\n    /**\n     * Instance name identifies particular Trilium instance. It can be useful for scripts\n     * if some action needs to happen on only one specific instance.\n     *\n     * @method\n     * @returns {string}\n     */\n    this.getInstanceName = () => window.glob.instanceName;\n\n    /**\n     * @method\n     * @param {Date} date\n     * @returns {string} date in YYYY-MM-DD format\n     */\n    this.formatDateISO = utils.formatDateISO;\n\n    /**\n     * @method\n     * @param {string} str\n     * @returns {Date} parsed object\n     */\n    this.parseDate = utils.parseDate;\n\n    /**\n     * Show an info toast message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showMessage = toastService.showMessage;\n\n    /**\n     * Show an error toast message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showError = toastService.showError;\n\n    /**\n     * Show an info dialog to the user.\n     *\n     * @method\n     * @param {string} message\n     * @returns {Promise}\n     */\n    this.showInfoDialog = dialogService.info;\n\n    /**\n     * Show confirm dialog to the user.\n     *\n     * @method\n     * @param {string} message\n     * @returns {Promise<boolean>} promise resolving to true if the user confirmed\n     */\n    this.showConfirmDialog = dialogService.confirm;\n\n    /**\n     * Show prompt dialog to the user.\n     *\n     * @method\n     * @param {object} props\n     * @param {string} props.title\n     * @param {string} props.message\n     * @param {string} props.defaultValue\n     * @returns {Promise<string>} promise resolving to the answer provided by the user\n     */\n    this.showPromptDialog = dialogService.prompt;\n\n    /**\n     * Trigger command. This is a very low-level API which should be avoided if possible.\n     *\n     * @method\n     * @param {string} name\n     * @param {object} data\n     */\n    this.triggerCommand = (name, data) => appContext.triggerCommand(name, data);\n\n    /**\n     * Trigger event. This is a very low-level API which should be avoided if possible.\n     *\n     * @method\n     * @param {string} name\n     * @param {object} data\n     */\n    this.triggerEvent = (name, data) => appContext.triggerEvent(name, data);\n\n    /**\n     * Create a note link (jQuery object) for given note.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {object} [params]\n     * @param {boolean} [params.showTooltip=true] - enable/disable tooltip on the link\n     * @param {boolean} [params.showNotePath=false] - show also whole note's path as part of the link\n     * @param {boolean} [params.showNoteIcon=false] - show also note icon before the title\n     * @param {string} [params.title] - custom link tile with note's title as default\n     * @param {string} [params.title=] - custom link tile with note's title as default\n     * @returns {jQuery} - jQuery element with the link (wrapped in <span>)\n     */\n    this.createLink = linkService.createLink;\n\n    /** @deprecated - use api.createLink() instead */\n    this.createNoteLink = linkService.createLink;\n\n    /**\n     * Adds given text to the editor cursor\n     *\n     * @method\n     * @param {string} text - this must be clear text, HTML is not supported.\n     */\n    this.addTextToActiveContextEditor = text => appContext.triggerCommand('addTextToActiveEditor', {text});\n\n    /**\n     * @method\n     * @returns {FNote} active note (loaded into center pane)\n     */\n    this.getActiveContextNote = () => appContext.tabManager.getActiveContextNote();\n\n    /**\n     * @method\n     * @returns {NoteContext} - returns active context (split)\n     */\n    this.getActiveContext = () => appContext.tabManager.getActiveContext();\n\n    /**\n     * @method\n     * @returns {NoteContext} - returns active main context (first split in a tab, represents the tab as a whole)\n     */\n    this.getActiveMainContext = () => appContext.tabManager.getActiveMainContext();\n\n    /**\n     * @method\n     * @returns {NoteContext[]} - returns all note contexts (splits) in all tabs\n     */\n    this.getNoteContexts = () => appContext.tabManager.getNoteContexts();\n\n    /**\n     * @method\n     * @returns {NoteContext[]} - returns all main contexts representing tabs\n     */\n    this.getMainNoteContexts = () => appContext.tabManager.getMainNoteContexts();\n\n    /**\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html for documentation on the returned instance.\n     *\n     * @method\n     * @returns {Promise<BalloonEditor>} instance of CKEditor\n     */\n    this.getActiveContextTextEditor = () => appContext.tabManager.getActiveContext()?.getTextEditor();\n\n    /**\n     * See https://codemirror.net/doc/manual.html#api\n     *\n     * @method\n     * @returns {Promise<CodeMirror>} instance of CodeMirror\n     */\n    this.getActiveContextCodeEditor = () => appContext.tabManager.getActiveContext()?.getCodeEditor();\n\n    /**\n     * Get access to the widget handling note detail. Methods like `getWidgetType()` and `getTypeWidget()` to get to the\n     * implementation of actual widget type.\n     *\n     * @method\n     * @returns {Promise<NoteDetailWidget>}\n     */\n    this.getActiveNoteDetailWidget = () => new Promise(resolve => appContext.triggerCommand('executeInActiveNoteDetailWidget', {callback: resolve}));\n\n    /**\n     * @method\n     * @returns {Promise<string|null>} returns a note path of active note or null if there isn't active note\n     */\n    this.getActiveContextNotePath = () => appContext.tabManager.getActiveContextNotePath();\n\n    /**\n     * Returns component which owns the given DOM element (the nearest parent component in DOM tree)\n     *\n     * @method\n     * @param {Element} el - DOM element\n     * @returns {Component}\n     */\n    this.getComponentByEl = el => appContext.getComponentByEl(el);\n\n    /**\n     * @method\n     * @param {object} $el - jquery object on which to set up the tooltip\n     * @returns {Promise<void>}\n     */\n    this.setupElementTooltip = noteTooltipService.setupElementTooltip;\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect note, false to unprotect\n     * @returns {Promise<void>}\n     */\n    this.protectNote = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect subtree, false to unprotect\n     * @returns {Promise<void>}\n     */\n    this.protectSubTree = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, true);\n    };\n\n    /**\n     * Returns date-note for today. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @returns {Promise<FNote>}\n     */\n    this.getTodayNote = dateNotesService.getTodayNote;\n\n    /**\n     * Returns day note for a given date. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @returns {Promise<FNote>}\n     */\n    this.getDayNote = dateNotesService.getDayNote;\n\n    /**\n     * Returns day note for the first date of the week of the given date. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @returns {Promise<FNote>}\n     */\n    this.getWeekNote = dateNotesService.getWeekNote;\n\n    /**\n     * Returns month-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} month - e.g. \"2019-04\"\n     * @returns {Promise<FNote>}\n     */\n    this.getMonthNote = dateNotesService.getMonthNote;\n\n    /**\n     * Returns year-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} year - e.g. \"2019\"\n     * @returns {Promise<FNote>}\n     */\n    this.getYearNote = dateNotesService.getYearNote;\n\n    /**\n     * Hoist note in the current tab. See https://github.com/zadam/trilium/wiki/Note-hoisting\n     *\n     * @method\n     * @param {string} noteId - set hoisted note. 'root' will effectively unhoist\n     * @returns {Promise<void>}\n     */\n    this.setHoistedNoteId = (noteId) => {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (activeNoteContext) {\n            activeNoteContext.setHoistedNoteId(noteId);\n        }\n    };\n\n    /**\n     * @method\n     * @param {string} keyboardShortcut - e.g. \"ctrl+shift+a\"\n     * @param {function} handler\n     * @param {string} [namespace] - specify namespace of the handler for the cases where call for bind may be repeated.\n     *                               If a handler with this ID exists, it's replaced by the new handler.\n     * @returns {Promise<void>}\n     */\n    this.bindGlobalShortcut = shortcutService.bindGlobalShortcut;\n\n    /**\n     * Trilium runs in a backend and frontend process, when something is changed on the backend from a script,\n     * frontend will get asynchronously synchronized.\n     *\n     * This method returns a promise which resolves once all the backend -> frontend synchronization is finished.\n     * Typical use case is when a new note has been created, we should wait until it is synced into frontend and only then activate it.\n     *\n     * @method\n     * @returns {Promise<void>}\n     */\n    this.waitUntilSynced = ws.waitForMaxKnownEntityChangeId;\n\n    /**\n     * This will refresh all currently opened notes which have included note specified in the parameter\n     *\n     * @param includedNoteId - noteId of the included note\n     * @returns {Promise<void>}\n     */\n    this.refreshIncludedNote = includedNoteId => appContext.triggerEvent('refreshIncludedNote', {noteId: includedNoteId});\n\n    /**\n     * Return randomly generated string of given length. This random string generation is NOT cryptographically secure.\n     *\n     * @method\n     * @param {int} length of the string\n     * @returns {string} random string\n     */\n    this.randomString = utils.randomString;\n\n    /**\n     * @method\n     * @param {int} size in bytes\n     * @return {string} formatted string\n     */\n    this.formatSize = utils.formatSize;\n\n    /**\n     * @method\n     * @param {int} size in bytes\n     * @return {string} formatted string\n     * @deprecated - use api.formatSize()\n     */\n    this.formatNoteSize = utils.formatSize;\n\n    this.logMessages = {};\n    this.logSpacedUpdates = {};\n\n    /**\n     * Log given message to the log pane in UI\n     *\n     * @param message\n     * @returns {void}\n     */\n    this.log = message => {\n        const {noteId} = this.startNote;\n\n        message = `${utils.now()}: ${message}`;\n\n        console.log(`Script ${noteId}: ${message}`);\n\n        this.logMessages[noteId] = this.logMessages[noteId] || [];\n        this.logSpacedUpdates[noteId] = this.logSpacedUpdates[noteId] || new SpacedUpdate(() => {\n            const messages = this.logMessages[noteId];\n            this.logMessages[noteId] = [];\n\n            appContext.triggerEvent(\"apiLogMessages\", {noteId, messages});\n        }, 100);\n\n        this.logMessages[noteId].push(message);\n        this.logSpacedUpdates[noteId].scheduleUpdate();\n    };\n}\n\nexport default FrontendScriptApi;\n","import FrontendScriptApi from './frontend_script_api.js';\nimport utils from './utils.js';\nimport froca from './froca.js';\n\nasync function ScriptContext(startNoteId, allNoteIds, originEntity = null, $container = null) {\n    const modules = {};\n\n    await froca.initializedPromise;\n\n    const startNote = await froca.getNote(startNoteId);\n    const allNotes = await froca.getNotes(allNoteIds);\n\n    return {\n        modules: modules,\n        notes: utils.toObject(allNotes, note => [note.noteId, note]),\n        apis: utils.toObject(allNotes, note => [note.noteId, new FrontendScriptApi(startNote, note, originEntity, $container)]),\n        require: moduleNoteIds => {\n            return moduleName => {\n                const candidates = allNotes.filter(note => moduleNoteIds.includes(note.noteId));\n                const note = candidates.find(c => c.title === moduleName);\n\n                if (!note) {\n                    throw new Error(`Could not find module note ${moduleName}`);\n                }\n\n                return modules[note.noteId].exports;\n            }\n        }\n    };\n}\n\nexport default ScriptContext;","import server from \"./server.js\";\nimport froca from \"./froca.js\";\n\nasync function searchForNoteIds(searchString) {\n    return await server.get(`search/${encodeURIComponent(searchString)}`);\n}\n\nasync function searchForNotes(searchString) {\n    const noteIds = await searchForNoteIds(searchString);\n\n    return await froca.getNotes(noteIds);\n}\n\nexport default {\n    searchForNoteIds,\n    searchForNotes\n}\n","export default class ValidationError {\n    constructor(resp) {\n        for (const key in resp) {\n            this[key] = resp[key];\n        }\n    }\n}","import utils from './utils.js';\nimport ValidationError from \"./validation_error.js\";\n\nasync function getHeaders(headers) {\n    const appContext = (await import('../components/app_context.js')).default;\n    const activeNoteContext = appContext.tabManager ? appContext.tabManager.getActiveContext() : null;\n\n    // headers need to be lowercase because node.js automatically converts them to lower case\n    // also avoiding using underscores instead of dashes since nginx filters them out by default\n    const allHeaders = {\n        'trilium-component-id': glob.componentId,\n        'trilium-local-now-datetime': utils.localNowDateTime(),\n        'trilium-hoisted-note-id': activeNoteContext ? activeNoteContext.hoistedNoteId : null,\n        'x-csrf-token': glob.csrfToken\n    };\n\n    for (const headerName in headers) {\n        if (headers[headerName]) {\n            allHeaders[headerName] = headers[headerName];\n        }\n    }\n\n    if (utils.isElectron()) {\n        // passing it explicitly here because of the electron HTTP bypass\n        allHeaders.cookie = document.cookie;\n    }\n\n    return allHeaders;\n}\n\nasync function getWithSilentNotFound(url, componentId) {\n    return await call('GET', url, componentId, { silentNotFound: true });\n}\n\nasync function get(url, componentId) {\n    return await call('GET', url, componentId);\n}\n\nasync function post(url, data, componentId) {\n    return await call('POST', url, componentId, { data });\n}\n\nasync function put(url, data, componentId) {\n    return await call('PUT', url, componentId, { data });\n}\n\nasync function patch(url, data, componentId) {\n    return await call('PATCH', url, componentId, { data });\n}\n\nasync function remove(url, componentId) {\n    return await call('DELETE', url, componentId);\n}\n\nasync function upload(url, fileToUpload) {\n    const formData = new FormData();\n    formData.append('upload', fileToUpload);\n\n    return await $.ajax({\n        url: window.glob.baseApiUrl + url,\n        headers: await getHeaders(),\n        data: formData,\n        type: 'PUT',\n        timeout: 60 * 60 * 1000,\n        contentType: false, // NEEDED, DON'T REMOVE THIS\n        processData: false, // NEEDED, DON'T REMOVE THIS\n    });\n}\n\nlet idCounter = 1;\nconst idToRequestMap = {};\n\nlet maxKnownEntityChangeId = 0;\n\nasync function call(method, url, componentId, options = {}) {\n    let resp;\n\n    const headers = await getHeaders({\n        'trilium-component-id': componentId\n    });\n    const {data} = options;\n\n    if (utils.isElectron()) {\n        const ipc = utils.dynamicRequire('electron').ipcRenderer;\n        const requestId = idCounter++;\n\n        resp = await new Promise((resolve, reject) => {\n            idToRequestMap[requestId] = {\n                resolve,\n                reject,\n                silentNotFound: !!options.silentNotFound\n            };\n\n            ipc.send('server-request', {\n                requestId: requestId,\n                headers: headers,\n                method: method,\n                url: `/${window.glob.baseApiUrl}${url}`,\n                data: data\n            });\n        });\n    }\n    else {\n        resp = await ajax(url, method, data, headers, !!options.silentNotFound);\n    }\n\n    const maxEntityChangeIdStr = resp.headers['trilium-max-entity-change-id'];\n\n    if (maxEntityChangeIdStr && maxEntityChangeIdStr.trim()) {\n        maxKnownEntityChangeId = Math.max(maxKnownEntityChangeId, parseInt(maxEntityChangeIdStr));\n    }\n\n    return resp.body;\n}\n\nfunction ajax(url, method, data, headers, silentNotFound) {\n    return new Promise((res, rej) => {\n        const options = {\n            url: window.glob.baseApiUrl + url,\n            type: method,\n            headers: headers,\n            timeout: 60000,\n            success: (body, textStatus, jqXhr) => {\n                const respHeaders = {};\n\n                jqXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(line => {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    respHeaders[header] = parts.join(': ');\n                });\n\n                res({\n                    body,\n                    headers: respHeaders\n                });\n            },\n            error: async jqXhr => {\n                if (silentNotFound && jqXhr.status === 404) {\n                    // report nothing\n                } else {\n                    await reportError(method, url, jqXhr.status, jqXhr.responseText);\n                }\n\n                rej(jqXhr.responseText);\n            }\n        };\n\n        if (data) {\n            try {\n                options.data = JSON.stringify(data);\n            } catch (e) {\n                console.log(\"Can't stringify data: \", data, \" because of error: \", e)\n            }\n            options.contentType = \"application/json\";\n        }\n\n        $.ajax(options);\n    });\n}\n\nif (utils.isElectron()) {\n    const ipc = utils.dynamicRequire('electron').ipcRenderer;\n\n    ipc.on('server-response', async (event, arg) => {\n        if (arg.statusCode >= 200 && arg.statusCode < 300) {\n            handleSuccessfulResponse(arg);\n        }\n        else {\n            if (arg.statusCode === 404 && idToRequestMap[arg.requestId]?.silentNotFound) {\n                // report nothing\n            } else {\n                await reportError(arg.method, arg.url, arg.statusCode, arg.body);\n            }\n\n            idToRequestMap[arg.requestId].reject(new Error(`Server responded with ${arg.statusCode}`));\n        }\n\n        delete idToRequestMap[arg.requestId];\n    });\n\n    function handleSuccessfulResponse(arg) {\n        if (arg.headers['Content-Type'] === 'application/json') {\n            arg.body = JSON.parse(arg.body);\n        }\n\n        if (!(arg.requestId in idToRequestMap)) {\n            // this can happen when reload happens between firing up the request and receiving the response\n            throw new Error(`Unknown requestId '${arg.requestId}'`);\n        }\n\n        idToRequestMap[arg.requestId].resolve({\n            body: arg.body,\n            headers: arg.headers\n        });\n    }\n}\n\nasync function reportError(method, url, statusCode, response) {\n    let message = response;\n\n    if (typeof response === 'string') {\n        try {\n            response = JSON.parse(response);\n            message = response.message;\n        }\n        catch (e) {}\n    }\n\n    const toastService = (await import(\"./toast.js\")).default;\n\n    if ([400, 404].includes(statusCode) && response && typeof response === 'object') {\n        toastService.showError(message);\n        throw new ValidationError({\n            requestUrl: url,\n            method,\n            statusCode,\n            ...response\n        });\n    } else {\n        const title = `${statusCode} ${method} ${url}`;\n        toastService.showErrorTitleAndMessage(title, message);\n        toastService.throwError(`${title} - ${message}`);\n    }\n}\n\nexport default {\n    get,\n    getWithSilentNotFound,\n    post,\n    put,\n    patch,\n    remove,\n    upload,\n    // don't remove, used from CKEditor image upload!\n    getHeaders,\n    getMaxKnownEntityChangeId: () => maxKnownEntityChangeId\n};\n","export default class SpacedUpdate {\n    constructor(updater, updateInterval = 1000) {\n        this.updater = updater;\n        this.lastUpdated = Date.now();\n        this.changed = false;\n        this.updateInterval = updateInterval;\n    }\n\n    scheduleUpdate() {\n        if (!this.changeForbidden) {\n            this.changed = true;\n            setTimeout(() => this.triggerUpdate());\n        }\n    }\n\n    async updateNowIfNecessary() {\n        if (this.changed) {\n            this.changed = false; // optimistic...\n\n            try {\n                await this.updater();\n            }\n            catch (e) {\n                this.changed = true;\n\n                throw e;\n            }\n        }\n    }\n\n    isAllSavedAndTriggerUpdate() {\n        const allSaved = !this.changed;\n\n        this.updateNowIfNecessary();\n\n        return allSaved;\n    }\n\n    triggerUpdate() {\n        if (!this.changed) {\n            return;\n        }\n\n        if (Date.now() - this.lastUpdated > this.updateInterval) {\n            this.updater();\n            this.lastUpdated = Date.now();\n            this.changed = false;\n        }\n        else {\n            // update isn't triggered but changes are still pending, so we need to schedule another check\n            this.scheduleUpdate();\n        }\n    }\n\n    async allowUpdateWithoutChange(callback) {\n        this.changeForbidden = true;\n\n        try {\n            await callback();\n        }\n        finally {\n            this.changeForbidden = false;\n        }\n    }\n}\n","import ws from \"./ws.js\";\nimport utils from \"./utils.js\";\n\nfunction toast(options) {\n    const $toast = $(`<div class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n    <div class=\"toast-header\">\n        <strong class=\"mr-auto\"><span class=\"bx bx-${options.icon}\"></span> <span class=\"toast-title\"></span></strong>\n        <button type=\"button\" class=\"ml-2 mb-1 close\" data-dismiss=\"toast\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n        </button>\n    </div>\n    <div class=\"toast-body\"></div>\n</div>`);\n\n    $toast.find('.toast-title').text(options.title);\n    $toast.find('.toast-body').text(options.message);\n\n    if (options.id) {\n        $toast.attr(\"id\", `toast-${options.id}`);\n    }\n\n    $(\"#toast-container\").append($toast);\n\n    $toast.toast({\n        delay: options.delay || 3000,\n        autohide: !!options.autohide\n    });\n\n    $toast.on('hidden.bs.toast', e => e.target.remove());\n\n    $toast.toast(\"show\");\n\n    return $toast;\n}\n\nfunction showPersistent(options) {\n    let $toast = $(`#toast-${options.id}`);\n\n    if ($toast.length > 0) {\n        $toast.find('.toast-body').html(options.message);\n    }\n    else {\n        options.autohide = false;\n\n        $toast = toast(options);\n    }\n\n    if (options.closeAfter) {\n        setTimeout(() => $toast.remove(), options.closeAfter);\n    }\n}\n\nfunction closePersistent(id) {\n    $(`#toast-${id}`).remove();\n}\n\nfunction showMessage(message, delay = 2000) {\n    console.debug(utils.now(), \"message:\", message);\n\n    toast({\n        title: \"信息\",\n        icon: \"check\",\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showAndLogError(message, delay = 10000) {\n    showError(message, delay);\n\n    ws.logError(message);\n}\n\nfunction showError(message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: \"错误\",\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showErrorTitleAndMessage(title, message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: title,\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction throwError(message) {\n    ws.logError(message);\n\n    throw new Error(message);\n}\n\nexport default {\n    showMessage,\n    showError,\n    showErrorTitleAndMessage,\n    showAndLogError,\n    throwError,\n    showPersistent,\n    closePersistent\n}\n","import ws from './ws.js';\nimport utils from './utils.js';\nimport froca from './froca.js';\nimport hoistedNoteService from '../services/hoisted_note.js';\nimport appContext from \"../components/app_context.js\";\n\n/**\n * @returns {string|null}\n */\nasync function resolveNotePath(notePath, hoistedNoteId = 'root') {\n    const runPath = await resolveNotePathToSegments(notePath, hoistedNoteId);\n\n    return runPath ? runPath.join(\"/\") : null;\n}\n\n/**\n * Accepts notePath which might or might not be valid and returns an existing path as close to the original\n * notePath as possible. Part of the path might not be valid because of note moving (which causes\n * path change) or other corruption, in that case, this will try to get some other valid path to the correct note.\n *\n * @returns {Promise<string[]>}\n */\nasync function resolveNotePathToSegments(notePath, hoistedNoteId = 'root', logErrors = true) {\n    utils.assertArguments(notePath);\n\n    // we might get notePath with the params suffix, remove it if present\n    notePath = notePath.split(\"?\")[0].trim();\n\n    if (notePath.length === 0) {\n        return null;\n    }\n\n    const path = notePath.split(\"/\").reverse();\n\n    if (!path.includes(\"root\")) {\n        path.push('root');\n    }\n\n    const effectivePathSegments = [];\n    let childNoteId = null;\n    let i = 0;\n\n    while (true) {\n        if (i >= path.length) {\n            break;\n        }\n\n        const parentNoteId = path[i++];\n\n        if (childNoteId !== null) {\n            const child = await froca.getNote(childNoteId, !logErrors);\n\n            if (!child) {\n                if (logErrors) {\n                    ws.logError(`Can't find note ${childNoteId}`);\n                }\n\n                return null;\n            }\n\n            child.sortParents();\n\n            const parents = child.getParentNotes();\n\n            if (!parents.length) {\n                if (logErrors) {\n                    ws.logError(`No parents found for note ${childNoteId} (${child.title}) for path ${notePath}`);\n                }\n\n                return null;\n            }\n\n            if (!parents.some(p => p.noteId === parentNoteId)) {\n                if (logErrors) {\n                    const parent = froca.getNoteFromCache(parentNoteId);\n\n                    console.debug(utils.now(), `Did not find parent ${parentNoteId} (${parent ? parent.title : 'n/a'}) \n                        for child ${childNoteId} (${child.title}), available parents: ${parents.map(p => `${p.noteId} (${p.title})`)}. \n                        You can ignore this message as it is mostly harmless.`);\n                }\n\n                const bestNotePath = child.getBestNotePath(hoistedNoteId);\n\n                if (bestNotePath) {\n                    const pathToRoot = bestNotePath.reverse().slice(1);\n\n                    for (const noteId of pathToRoot) {\n                        effectivePathSegments.push(noteId);\n                    }\n                }\n\n                break;\n            }\n        }\n\n        effectivePathSegments.push(parentNoteId);\n        childNoteId = parentNoteId;\n    }\n\n    effectivePathSegments.reverse();\n\n    if (effectivePathSegments.includes(hoistedNoteId)) {\n        return effectivePathSegments;\n    }\n    else {\n        const note = await froca.getNote(getNoteIdFromUrl(notePath));\n\n        const bestNotePath = note.getBestNotePath(hoistedNoteId);\n\n        if (!bestNotePath) {\n            throw new Error(`Did not find any path segments for '${note.toString()}', hoisted note '${hoistedNoteId}'`);\n        }\n\n        // if there isn't actually any note path with hoisted note, then return the original resolved note path\n        return bestNotePath.includes(hoistedNoteId) ? bestNotePath : effectivePathSegments;\n    }\n}\n\nws.subscribeToMessages(message => {\n   if (message.type === 'openNote') {\n       appContext.tabManager.activateOrOpenNote(message.noteId);\n\n       if (utils.isElectron()) {\n           const currentWindow = utils.dynamicRequire('@electron/remote').getCurrentWindow();\n\n           currentWindow.show();\n       }\n   }\n});\n\nfunction getParentProtectedStatus(node) {\n    return hoistedNoteService.isHoistedNode(node) ? false : node.getParent().data.isProtected;\n}\n\nfunction getNoteIdFromUrl(urlOrNotePath) {\n    if (!urlOrNotePath) {\n        return null;\n    }\n\n    const [notePath] = urlOrNotePath.split(\"?\");\n    const segments = notePath.split(\"/\");\n\n    return segments[segments.length - 1];\n}\n\nasync function getBranchIdFromUrl(urlOrNotePath) {\n    const {noteId, parentNoteId} = getNoteIdAndParentIdFromUrl(urlOrNotePath);\n\n    return await froca.getBranchId(parentNoteId, noteId);\n}\n\nfunction getNoteIdAndParentIdFromUrl(urlOrNotePath) {\n    if (!urlOrNotePath) {\n        return {};\n    }\n\n    const [notePath] = urlOrNotePath.split(\"?\");\n\n    if (notePath === 'root') {\n        return {\n            noteId: 'root',\n            parentNoteId: 'none'\n        };\n    }\n\n    let parentNoteId = 'root';\n    let noteId = '';\n\n    if (notePath) {\n        const segments = notePath.split(\"/\");\n\n        noteId = segments[segments.length - 1];\n\n        if (segments.length > 1) {\n            parentNoteId = segments[segments.length - 2];\n        }\n    }\n\n    return {\n        parentNoteId,\n        noteId\n    };\n}\n\nfunction getNotePath(node) {\n    if (!node) {\n        logError(\"节点为空\");\n        return \"\";\n    }\n\n    const path = [];\n\n    while (node) {\n        if (node.data.noteId) {\n            path.push(node.data.noteId);\n        }\n\n        node = node.getParent();\n    }\n\n    return path.reverse().join(\"/\");\n}\n\nasync function getNoteTitle(noteId, parentNoteId = null) {\n    utils.assertArguments(noteId);\n\n    const note = await froca.getNote(noteId);\n    if (!note) {\n        return \"[not found]\";\n    }\n\n    let {title} = note;\n\n    if (parentNoteId !== null) {\n        const branchId = note.parentToBranch[parentNoteId];\n\n        if (branchId) {\n            const branch = froca.getBranch(branchId);\n\n            if (branch?.prefix) {\n                title = `${branch.prefix} - ${title}`;\n            }\n        }\n    }\n\n    return title;\n}\n\nasync function getNotePathTitleComponents(notePath) {\n    const titleComponents = [];\n\n    if (notePath.startsWith('root/')) {\n        notePath = notePath.substr(5);\n    }\n\n    // special case when we want just root's title\n    if (notePath === 'root') {\n        titleComponents.push(await getNoteTitle(notePath));\n    } else {\n        let parentNoteId = 'root';\n\n        for (const noteId of notePath.split('/')) {\n            titleComponents.push(await getNoteTitle(noteId, parentNoteId));\n\n            parentNoteId = noteId;\n        }\n    }\n\n    return titleComponents;\n}\n\nasync function getNotePathTitle(notePath) {\n    utils.assertArguments(notePath);\n\n    const titlePath = await getNotePathTitleComponents(notePath);\n\n    return titlePath.join(' / ');\n}\n\nasync function getNoteTitleWithPathAsSuffix(notePath) {\n    utils.assertArguments(notePath);\n\n    const titleComponents = await getNotePathTitleComponents(notePath);\n\n    if (!titleComponents || titleComponents.length === 0) {\n        return \"\";\n    }\n\n    const title = titleComponents[titleComponents.length - 1];\n    const path = titleComponents.slice(0, titleComponents.length - 1);\n\n    const $titleWithPath = $('<span class=\"note-title-with-path\">')\n        .append($('<span class=\"note-title\">').text(title));\n\n    if (path.length > 0) {\n        $titleWithPath\n            .append($('<span class=\"note-path\">').text(` (${path.join(' / ')})`));\n    }\n\n    return $titleWithPath;\n}\n\nfunction isNotePathInHiddenSubtree(notePath) {\n    return notePath?.includes(\"root/_hidden\");\n}\n\nexport default {\n    resolveNotePath,\n    resolveNotePathToSegments,\n    getParentProtectedStatus,\n    getNotePath,\n    getNoteIdFromUrl,\n    getNoteIdAndParentIdFromUrl,\n    getBranchIdFromUrl,\n    getNoteTitle,\n    getNotePathTitle,\n    getNoteTitleWithPathAsSuffix,\n    isNotePathInHiddenSubtree\n};\n","export default class LoadResults {\n    constructor(entityChanges) {\n        this.entities = {};\n\n        for (const {entityId, entityName, entity} of entityChanges) {\n            if (entity) {\n                this.entities[entityName] = this.entities[entityName] || [];\n                this.entities[entityName][entityId] = entity;\n            }\n        }\n\n        this.noteIdToComponentId = {};\n        this.componentIdToNoteIds = {};\n\n        this.branchRows = [];\n\n        this.attributeRows = [];\n\n        this.noteReorderings = [];\n\n        this.revisionRows = [];\n\n        this.contentNoteIdToComponentId = [];\n\n        this.optionNames = [];\n\n        this.attachmentRows = [];\n    }\n\n    getEntityRow(entityName, entityId) {\n        return this.entities[entityName]?.[entityId];\n    }\n\n    addNote(noteId, componentId) {\n        this.noteIdToComponentId[noteId] = this.noteIdToComponentId[noteId] || [];\n\n        if (!this.noteIdToComponentId[noteId].includes(componentId)) {\n            this.noteIdToComponentId[noteId].push(componentId);\n        }\n\n        this.componentIdToNoteIds[componentId] = this.componentIdToNoteIds[componentId] || [];\n\n        if (!this.componentIdToNoteIds[componentId]) {\n            this.componentIdToNoteIds[componentId].push(noteId);\n        }\n    }\n\n    addBranch(branchId, componentId) {\n        this.branchRows.push({branchId, componentId});\n    }\n\n    getBranchRows() {\n        return this.branchRows\n            .map(row => this.getEntityRow(\"branches\", row.branchId))\n            .filter(branch => !!branch);\n    }\n\n    addNoteReordering(parentNoteId, componentId) {\n        this.noteReorderings.push(parentNoteId);\n    }\n\n    getNoteReorderings() {\n        return this.noteReorderings;\n    }\n\n    addAttribute(attributeId, componentId) {\n        this.attributeRows.push({attributeId, componentId});\n    }\n\n    getAttributeRows(componentId = 'none') {\n        return this.attributeRows\n            .filter(row => row.componentId !== componentId)\n            .map(row => this.getEntityRow(\"attributes\", row.attributeId))\n            .filter(attr => !!attr);\n    }\n\n    addRevision(revisionId, noteId, componentId) {\n        this.revisionRows.push({revisionId, noteId, componentId});\n    }\n\n    hasRevisionForNote(noteId) {\n        return !!this.revisionRows.find(row => row.noteId === noteId);\n    }\n\n    getNoteIds() {\n        return Object.keys(this.noteIdToComponentId);\n    }\n\n    isNoteReloaded(noteId, componentId = null) {\n        if (!noteId) {\n            return false;\n        }\n\n        const componentIds = this.noteIdToComponentId[noteId];\n        return componentIds && componentIds.find(sId => sId !== componentId) !== undefined;\n    }\n\n    addNoteContent(noteId, componentId) {\n        this.contentNoteIdToComponentId.push({noteId, componentId});\n    }\n\n    isNoteContentReloaded(noteId, componentId) {\n        if (!noteId) {\n            return false;\n        }\n\n        return this.contentNoteIdToComponentId.find(l => l.noteId === noteId && l.componentId !== componentId);\n    }\n\n    addOption(name) {\n        this.optionNames.push(name);\n    }\n\n    isOptionReloaded(name) {\n        return this.optionNames.includes(name);\n    }\n\n    getOptionNames() {\n        return this.optionNames;\n    }\n\n    addAttachmentRow(attachment) {\n        this.attachmentRows.push(attachment);\n    }\n\n    getAttachmentRows() {\n        return this.attachmentRows;\n    }\n\n    /**\n     * @returns {boolean} true if there are changes which could affect the attributes (including inherited ones)\n     *          notably changes in note itself should not have any effect on attributes\n     */\n    hasAttributeRelatedChanges() {\n        return this.branchRows.length > 0\n            || this.attributeRows.length > 0;\n    }\n\n    isEmpty() {\n        return Object.keys(this.noteIdToComponentId).length === 0\n            && this.branchRows.length === 0\n            && this.attributeRows.length === 0\n            && this.noteReorderings.length === 0\n            && this.revisionRows.length === 0\n            && this.contentNoteIdToComponentId.length === 0\n            && this.optionNames.length === 0\n            && this.attachmentRows.length === 0;\n    }\n\n    isEmptyForTree() {\n        return Object.keys(this.noteIdToComponentId).length === 0\n            && this.branchRows.length === 0\n            && this.attributeRows.length === 0\n            && this.noteReorderings.length === 0;\n    }\n}\n","import LoadResults from \"./load_results.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport options from \"./options.js\";\nimport noteAttributeCache from \"./note_attribute_cache.js\";\nimport FBranch from \"../entities/fbranch.js\";\nimport FAttribute from \"../entities/fattribute.js\";\nimport FAttachment from \"../entities/fattachment.js\";\n\nasync function processEntityChanges(entityChanges) {\n    const loadResults = new LoadResults(entityChanges);\n\n    for (const ec of entityChanges) {\n        try {\n            if (ec.entityName === 'notes') {\n                processNoteChange(loadResults, ec);\n            } else if (ec.entityName === 'branches') {\n                await processBranchChange(loadResults, ec);\n            } else if (ec.entityName === 'attributes') {\n                processAttributeChange(loadResults, ec);\n            } else if (ec.entityName === 'note_reordering') {\n                processNoteReordering(loadResults, ec);\n            } else if (ec.entityName === 'revisions') {\n                loadResults.addRevision(ec.entityId, ec.noteId, ec.componentId);\n            } else if (ec.entityName === 'options') {\n                if (ec.entity.name === 'openNoteContexts') {\n                    continue; // only noise\n                }\n\n                options.set(ec.entity.name, ec.entity.value);\n\n                loadResults.addOption(ec.entity.name);\n            } else if (ec.entityName === 'attachments') {\n                processAttachment(loadResults, ec);\n            } else if (ec.entityName === 'blobs' || ec.entityName === 'etapi_tokens') {\n                // NOOP\n            }\n            else {\n                throw new Error(`Unknown entityName '${ec.entityName}'`);\n            }\n        }\n        catch (e) {\n            throw new Error(`Can't process entity ${JSON.stringify(ec)} with error ${e.message} ${e.stack}`);\n        }\n    }\n\n    // froca is supposed to contain all notes currently being visible to the users in the tree / otherwise being processed\n    // and their complete \"ancestor relationship\", so it's always possible to go up in the hierarchy towards the root.\n    // To this we count: standard parent-child relationships and template/inherit relations (attribute inheritance follows them).\n    // Here we watch for changes which might violate this principle - e.g., an introduction of a new \"inherit\" relation might\n    // mean we need to load the target of the relation (and then perhaps transitively the whole note path of this target).\n    const missingNoteIds = [];\n\n    for (const {entityName, entity} of entityChanges) {\n        if (!entity) { // if erased\n            continue;\n        }\n\n        if (entityName === 'branches' && !(entity.parentNoteId in froca.notes)) {\n            missingNoteIds.push(entity.parentNoteId);\n        }\n        else if (entityName === 'attributes'\n            && entity.type === 'relation'\n            && (entity.name === 'template' || entity.name === 'inherit')\n            && !(entity.value in froca.notes)) {\n\n            missingNoteIds.push(entity.value);\n        }\n    }\n\n    if (missingNoteIds.length > 0) {\n        await froca.reloadNotes(missingNoteIds);\n    }\n\n    if (!loadResults.isEmpty()) {\n        if (loadResults.hasAttributeRelatedChanges()) {\n            noteAttributeCache.invalidate();\n        }\n\n        const appContext = (await import(\"../components/app_context.js\")).default;\n        await appContext.triggerEvent('entitiesReloaded', {loadResults});\n    }\n}\n\nfunction processNoteChange(loadResults, ec) {\n    const note = froca.notes[ec.entityId];\n\n    if (!note) {\n        // if this note has not been requested before then it's not part of froca's cached subset, and\n        // we're not interested in it\n        return;\n    }\n\n    loadResults.addNote(ec.entityId, ec.componentId);\n\n    if (ec.isErased && ec.entityId in froca.notes) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        delete froca.notes[ec.entityId];\n    }\n    else {\n        if (note.blobId !== ec.entity.blobId) {\n            for (const key of Object.keys(froca.blobPromises)) {\n                if (key.includes(note.noteId)) {\n                    delete froca.blobPromises[key];\n                }\n            }\n\n            loadResults.addNoteContent(note.noteId, ec.componentId);\n        }\n\n        note.update(ec.entity);\n    }\n}\n\nasync function processBranchChange(loadResults, ec) {\n    if (ec.isErased && ec.entityId in froca.branches) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    let branch = froca.branches[ec.entityId];\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (branch) {\n            const childNote = froca.notes[branch.noteId];\n            const parentNote = froca.notes[branch.parentNoteId];\n\n            if (childNote) {\n                childNote.parents = childNote.parents.filter(parentNoteId => parentNoteId !== branch.parentNoteId);\n                delete childNote.parentToBranch[branch.parentNoteId];\n            }\n\n            if (parentNote) {\n                parentNote.children = parentNote.children.filter(childNoteId => childNoteId !== branch.noteId);\n                delete parentNote.childToBranch[branch.noteId];\n            }\n\n            loadResults.addBranch(ec.entityId, ec.componentId);\n\n            delete froca.branches[ec.entityId];\n        }\n\n        return;\n    }\n\n    loadResults.addBranch(ec.entityId, ec.componentId);\n\n    const childNote = froca.notes[ec.entity.noteId];\n    let parentNote = froca.notes[ec.entity.parentNoteId];\n\n    if (childNote && !childNote.isRoot() && !parentNote) {\n        // a branch cannot exist without the parent\n        // a note loaded into froca has to also contain all its ancestors,\n        // this problem happened, e.g., in sharing where _share was hidden and thus not loaded\n        // sharing meant cloning into _share, which crashed because _share was not loaded\n        parentNote = await froca.getNote(ec.entity.parentNoteId);\n    }\n\n    if (branch) {\n        branch.update(ec.entity);\n    }\n    else if (childNote || parentNote) {\n        froca.branches[ec.entityId] = branch = new FBranch(froca, ec.entity);\n    }\n\n    if (childNote) {\n        childNote.addParent(branch.parentNoteId, branch.branchId);\n    }\n\n    if (parentNote) {\n        parentNote.addChild(branch.noteId, branch.branchId);\n    }\n}\n\nfunction processNoteReordering(loadResults, ec) {\n    const parentNoteIdsToSort = new Set();\n\n    for (const branchId in ec.positions) {\n        const branch = froca.branches[branchId];\n\n        if (branch) {\n            branch.notePosition = ec.positions[branchId];\n\n            parentNoteIdsToSort.add(branch.parentNoteId);\n        }\n    }\n\n    for (const parentNoteId of parentNoteIdsToSort) {\n        const parentNote = froca.notes[parentNoteId];\n\n        if (parentNote) {\n            parentNote.sortChildren();\n        }\n    }\n\n    loadResults.addNoteReordering(ec.entityId, ec.componentId);\n}\n\nfunction processAttributeChange(loadResults, ec) {\n    let attribute = froca.attributes[ec.entityId];\n\n    if (ec.isErased && ec.entityId in froca.attributes) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (attribute) {\n            const sourceNote = froca.notes[attribute.noteId];\n            const targetNote = attribute.type === 'relation' && froca.notes[attribute.value];\n\n            if (sourceNote) {\n                sourceNote.attributes = sourceNote.attributes.filter(attributeId => attributeId !== attribute.attributeId);\n            }\n\n            if (targetNote) {\n                targetNote.targetRelations = targetNote.targetRelations.filter(attributeId => attributeId !== attribute.attributeId);\n            }\n\n            loadResults.addAttribute(ec.entityId, ec.componentId);\n\n            delete froca.attributes[ec.entityId];\n        }\n\n        return;\n    }\n\n    loadResults.addAttribute(ec.entityId, ec.componentId);\n\n    const sourceNote = froca.notes[ec.entity.noteId];\n    const targetNote = ec.entity.type === 'relation' && froca.notes[ec.entity.value];\n\n    if (attribute) {\n        attribute.update(ec.entity);\n    } else if (sourceNote || targetNote) {\n        attribute = new FAttribute(froca, ec.entity);\n\n        froca.attributes[attribute.attributeId] = attribute;\n\n        if (sourceNote && !sourceNote.attributes.includes(attribute.attributeId)) {\n            sourceNote.attributes.push(attribute.attributeId);\n        }\n\n        if (targetNote && !targetNote.targetRelations.includes(attribute.attributeId)) {\n            targetNote.targetRelations.push(attribute.attributeId);\n        }\n    }\n}\n\nfunction processAttachment(loadResults, ec) {\n    if (ec.isErased && ec.entityId in froca.attachments) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    const attachment = froca.attachments[ec.entityId];\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (attachment) {\n            const note = attachment.getNote();\n\n            if (note && note.attachments) {\n                note.attachments = note.attachments.filter(att => att.attachmentId !== attachment.attachmentId);\n            }\n\n            loadResults.addAttachmentRow(ec.entity);\n\n            delete froca.attachments[ec.entityId];\n        }\n\n        return;\n    }\n\n    if (attachment) {\n        attachment.update(ec.entity);\n    } else {\n        const note = froca.notes[ec.entity.ownerId];\n\n        if (note?.attachments) {\n            note.attachments.push(new FAttachment(froca, ec.entity));\n        }\n    }\n\n    loadResults.addAttachmentRow(ec.entity);\n}\n\nexport default {\n    processEntityChanges\n}\n","import utils from './utils.js';\nimport toastService from \"./toast.js\";\nimport server from \"./server.js\";\nimport options from \"./options.js\";\nimport frocaUpdater from \"./froca_updater.js\";\nimport appContext from \"../components/app_context.js\";\n\nconst messageHandlers = [];\n\nlet ws;\nlet lastAcceptedEntityChangeId = window.glob.maxEntityChangeIdAtLoad;\nlet lastAcceptedEntityChangeSyncId = window.glob.maxEntityChangeSyncIdAtLoad;\nlet lastProcessedEntityChangeId = window.glob.maxEntityChangeIdAtLoad;\nlet lastPingTs;\nlet frontendUpdateDataQueue = [];\n\nfunction logError(message) {\n    console.error(utils.now(), message); // needs to be separate from .trace()\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-error',\n            error: message,\n            stack: new Error().stack\n        }));\n    }\n}\n\nfunction logInfo(message) {\n    console.log(utils.now(), message);\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-info',\n            info: message\n        }));\n    }\n}\n\nwindow.logError = logError;\nwindow.logInfo = logInfo;\n\nfunction subscribeToMessages(messageHandler) {\n    messageHandlers.push(messageHandler);\n}\n\n// used to serialize frontend update operations\nlet consumeQueuePromise = null;\n\n// to make sure each change event is processed only once. Not clear if this is still necessary\nconst processedEntityChangeIds = new Set();\n\nfunction logRows(entityChanges) {\n    const filteredRows = entityChanges.filter(row =>\n        !processedEntityChangeIds.has(row.id)\n        && (row.entityName !== 'options' || row.entityId !== 'openNoteContexts'));\n\n    if (filteredRows.length > 0) {\n        console.debug(utils.now(), \"Frontend update data: \", filteredRows);\n    }\n}\n\nasync function executeFrontendUpdate(entityChanges) {\n    lastPingTs = Date.now();\n\n    if (entityChanges.length > 0) {\n        logRows(entityChanges);\n\n        frontendUpdateDataQueue.push(...entityChanges);\n\n        // we set lastAcceptedEntityChangeId even before frontend update processing and send ping so that backend can start sending more updates\n\n        for (const entityChange of entityChanges) {\n            lastAcceptedEntityChangeId = Math.max(lastAcceptedEntityChangeId, entityChange.id);\n\n            if (entityChange.isSynced) {\n                lastAcceptedEntityChangeSyncId = Math.max(lastAcceptedEntityChangeSyncId, entityChange.id);\n            }\n        }\n\n        sendPing();\n\n        // first wait for all the preceding consumers to finish\n        while (consumeQueuePromise) {\n            await consumeQueuePromise;\n        }\n\n        try {\n            // it's my turn, so start it up\n            consumeQueuePromise = consumeFrontendUpdateData();\n\n            await consumeQueuePromise;\n        } finally {\n            // finish and set to null to signal somebody else can pick it up\n            consumeQueuePromise = null;\n        }\n    }\n}\n\nasync function handleMessage(event) {\n    const message = JSON.parse(event.data);\n\n    for (const messageHandler of messageHandlers) {\n        messageHandler(message);\n    }\n\n    if (message.type === 'ping') {\n        lastPingTs = Date.now();\n    }\n    else if (message.type === 'reload-frontend') {\n        utils.reloadFrontendApp(\"received request from backend to reload frontend\");\n    }\n    else if (message.type === 'frontend-update') {\n        await executeFrontendUpdate(message.data.entityChanges);\n    }\n    else if (message.type === 'sync-hash-check-failed') {\n        toastService.showError(\"同步检查失败!\", 60000);\n    }\n    else if (message.type === 'consistency-checks-failed') {\n        toastService.showError(\"一致性检查失败! 详情请看日志.\", 50 * 60000);\n    }\n    else if (message.type === 'api-log-messages') {\n        appContext.triggerEvent(\"apiLogMessages\", {noteId: message.noteId, messages: message.messages});\n    }\n    else if (message.type === 'toast') {\n        toastService.showMessage(message.message);\n    }\n    else if (message.type === 'execute-script') {\n        const bundleService = (await import(\"../services/bundle.js\")).default;\n        const froca = (await import(\"../services/froca.js\")).default;\n        const originEntity = message.originEntityId ? await froca.getNote(message.originEntityId) : null;\n\n        bundleService.getAndExecuteBundle(message.currentNoteId, originEntity, message.script, message.params);\n    }\n}\n\nlet entityChangeIdReachedListeners = [];\n\nfunction waitForEntityChangeId(desiredEntityChangeId) {\n    if (desiredEntityChangeId <= lastProcessedEntityChangeId) {\n        return Promise.resolve();\n    }\n\n    console.debug(`Waiting for ${desiredEntityChangeId}, last processed is ${lastProcessedEntityChangeId}, last accepted ${lastAcceptedEntityChangeId}`);\n\n    return new Promise((res, rej) => {\n        entityChangeIdReachedListeners.push({\n            desiredEntityChangeId: desiredEntityChangeId,\n            resolvePromise: res,\n            start: Date.now()\n        })\n    });\n}\n\nfunction waitForMaxKnownEntityChangeId() {\n    return waitForEntityChangeId(server.getMaxKnownEntityChangeId());\n}\n\nfunction checkEntityChangeIdListeners() {\n    entityChangeIdReachedListeners\n        .filter(l => l.desiredEntityChangeId <= lastProcessedEntityChangeId)\n        .forEach(l => l.resolvePromise());\n\n    entityChangeIdReachedListeners = entityChangeIdReachedListeners\n        .filter(l => l.desiredEntityChangeId > lastProcessedEntityChangeId);\n\n    entityChangeIdReachedListeners.filter(l => Date.now() > l.start - 60000)\n        .forEach(l => console.log(`Waiting for entityChangeId ${l.desiredEntityChangeId} while last processed is ${lastProcessedEntityChangeId} (last accepted ${lastAcceptedEntityChangeId}) for ${Math.floor((Date.now() - l.start) / 1000)}s`));\n}\n\nasync function consumeFrontendUpdateData() {\n    if (frontendUpdateDataQueue.length > 0) {\n        const allEntityChanges = frontendUpdateDataQueue;\n        frontendUpdateDataQueue = [];\n\n        const nonProcessedEntityChanges = allEntityChanges.filter(ec => !processedEntityChangeIds.has(ec.id));\n\n        try {\n            await utils.timeLimit(frocaUpdater.processEntityChanges(nonProcessedEntityChanges), 30000);\n        }\n        catch (e) {\n            logError(`发生错误 ${e.message}: ${e.stack}, 重新加载界面.`);\n\n            if (!glob.isDev && !options.is('debugModeEnabled')) {\n                // if there's an error in updating the frontend, then the easy option to recover is to reload the frontend completely\n\n                utils.reloadFrontendApp();\n            }\n            else {\n                console.log(\"nonProcessedEntityChanges causing the timeout\", nonProcessedEntityChanges);\n\n                toastService.showError(`Encountered error \"${e.message}\", check out the console.`);\n            }\n        }\n\n        for (const entityChange of nonProcessedEntityChanges) {\n            processedEntityChangeIds.add(entityChange.id);\n\n            lastProcessedEntityChangeId = Math.max(lastProcessedEntityChangeId, entityChange.id);\n        }\n    }\n\n    checkEntityChangeIdListeners();\n}\n\nfunction connectWebSocket() {\n    const loc = window.location;\n    const webSocketUri = `${loc.protocol === \"https:\" ? \"wss:\" : \"ws:\"}//${loc.host}${loc.pathname}`;\n\n    // use wss for secure messaging\n    const ws = new WebSocket(webSocketUri);\n    ws.onopen = () => console.debug(utils.now(), `Connected to server ${webSocketUri} with WebSocket`);\n    ws.onmessage = handleMessage;\n    // we're not handling ws.onclose here because reconnection is done in sendPing()\n\n    return ws;\n}\n\nasync function sendPing() {\n    if (Date.now() - lastPingTs > 30000) {\n        console.log(utils.now(), \"Lost websocket connection to the backend. If you keep having this issue repeatedly, you might want to check your reverse proxy (nginx, apache) configuration and allow/unblock WebSocket.\");\n    }\n\n    if (ws.readyState === ws.OPEN) {\n        ws.send(JSON.stringify({\n            type: 'ping',\n            lastEntityChangeId: lastAcceptedEntityChangeId\n        }));\n    }\n    else if (ws.readyState === ws.CLOSED || ws.readyState === ws.CLOSING) {\n        console.log(utils.now(), \"WS closed or closing, trying to reconnect\");\n\n        ws = connectWebSocket();\n    }\n}\n\nsetTimeout(() => {\n    ws = connectWebSocket();\n\n    lastPingTs = Date.now();\n\n    setInterval(sendPing, 1000);\n}, 0);\n\nexport default {\n    logError,\n    subscribeToMessages,\n    waitForMaxKnownEntityChangeId,\n    getMaxKnownEntityChangeSyncId: () => lastAcceptedEntityChangeSyncId\n};\n","import Component from \"../components/component.js\";\n\n\n/**\n * This is the base widget for all other widgets.\n *\n * For information on using widgets, see the tutorial {@tutorial widget_basics}.\n */\nclass BasicWidget extends Component {\n    constructor() {\n        super();\n\n        this.attrs = {\n            style: ''\n        };\n        this.classes = [];\n\n        this.children = [];\n        this.childPositionCounter = 10;\n    }\n\n    child(...components) {\n        if (!components) {\n            return this;\n        }\n\n        super.child(...components);\n\n        for (const component of components) {\n            if (component.position === undefined) {\n                component.position = this.childPositionCounter;\n                this.childPositionCounter += 10;\n            }\n        }\n\n        this.children.sort((a, b) => a.position - b.position);\n\n        return this;\n    }\n\n    id(id) {\n        this.attrs.id = id;\n        return this;\n    }\n\n    class(className) {\n        this.classes.push(className);\n        return this;\n    }\n\n    css(name, value) {\n        this.attrs.style += `${name}: ${value};`;\n        return this;\n    }\n\n    contentSized() {\n        this.css(\"contain\", \"none\");\n\n        return this;\n    }\n\n    collapsible() {\n        this.css('min-height', '0');\n        this.css('min-width', '0');\n        return this;\n    }\n\n    filling() {\n        this.css('flex-grow', '1');\n        return this;\n    }\n\n    /**\n     * Accepts a string of CSS to add with the widget.\n     * @param {string} block\n     * @returns {this} for chaining\n     */\n    cssBlock(block) {\n        this.cssEl = block;\n        return this;\n    }\n\n    render() {\n        this.doRender();\n\n        this.$widget.attr('data-component-id', this.componentId);\n        this.$widget\n            .addClass('component')\n            .prop('component', this);\n\n        if (!this.isEnabled()) {\n            this.toggleInt(false);\n        }\n\n        if (this.cssEl) {\n            const css = this.cssEl.trim().startsWith('<style>') ? this.cssEl : `<style>${this.cssEl}</style>`;\n\n            this.$widget.append(css);\n        }\n\n        for (const key in this.attrs) {\n            if (key === 'style') {\n                if (this.attrs[key]) {\n                    let style = this.$widget.attr('style');\n                    style = style ? `${style}; ${this.attrs[key]}` : this.attrs[key];\n\n                    this.$widget.attr(key, style);\n                }\n            }\n            else {\n                this.$widget.attr(key, this.attrs[key]);\n            }\n        }\n\n        for (const className of this.classes) {\n            this.$widget.addClass(className);\n        }\n\n        return this.$widget;\n    }\n\n    isEnabled() {\n        return true;\n    }\n\n    /**\n     * Method used for rendering the widget.\n     *\n     * Your class should override this method.\n     * The method is expected to create a this.$widget containing jQuery object\n     */\n    doRender() {}\n\n    toggleInt(show) {\n        this.$widget.toggleClass('hidden-int', !show);\n    }\n\n    isHiddenInt() {\n        return this.$widget.hasClass('hidden-int');\n    }\n\n    toggleExt(show) {\n        this.$widget.toggleClass('hidden-ext', !show);\n    }\n\n    isHiddenExt() {\n        return this.$widget.hasClass('hidden-ext');\n    }\n\n    canBeShown() {\n        return !this.isHiddenInt() && !this.isHiddenExt();\n    }\n\n    isVisible() {\n        return this.$widget.is(\":visible\");\n    }\n\n    getPosition() {\n        return this.position;\n    }\n\n    remove() {\n        if (this.$widget) {\n            this.$widget.remove();\n        }\n    }\n\n    getClosestNtxId() {\n        if (this.$widget) {\n            return this.$widget.closest(\"[data-ntx-id]\").attr(\"data-ntx-id\");\n        }\n        else {\n            return null;\n        }\n    }\n\n    cleanup() {}\n}\n\nexport default BasicWidget;\n","import BasicWidget from \"./basic_widget.js\";\nimport appContext from \"../components/app_context.js\";\n\n/**\n * This widget allows for changing and updating depending on the active note.\n * @extends {BasicWidget}\n */\nclass NoteContextAwareWidget extends BasicWidget {\n    isNoteContext(ntxId) {\n        if (Array.isArray(ntxId)) {\n            return this.noteContext && ntxId.includes(this.noteContext.ntxId);\n        }\n        else {\n            return this.noteContext && this.noteContext.ntxId === ntxId;\n        }\n    }\n\n    isActiveNoteContext() {\n        return appContext.tabManager.getActiveContext() === this.noteContext;\n    }\n\n    isNote(noteId) {\n        return this.noteId === noteId;\n    }\n\n    /** @returns {FNote|undefined} */\n    get note() {\n        return this.noteContext?.note;\n    }\n\n    /** @returns {string|undefined} */\n    get noteId() {\n        return this.note?.noteId;\n    }\n\n    /** @returns {string|undefined} */\n    get notePath() {\n        return this.noteContext?.notePath;\n    }\n\n    /** @returns {string} */\n    get hoistedNoteId() {\n        return this.noteContext?.hoistedNoteId;\n    }\n\n    get ntxId() {\n        return this.noteContext?.ntxId;\n    }\n\n    /**\n     * @returns {boolean} true when an active note exists\n     */\n    isEnabled() {\n        return !!this.note;\n    }\n\n    async refresh() {\n        if (this.isEnabled()) {\n            this.toggleInt(true);\n            await this.refreshWithNote(this.note);\n        }\n        else {\n            this.toggleInt(false);\n        }\n    }\n\n    /**\n     * Override this method to be able to refresh your\n     * widget with each note.\n     * @param {FNote} note\n     * @returns {Promise<void>}\n     */\n    async refreshWithNote(note) {}\n\n    async noteSwitchedEvent({noteContext, notePath}) {\n        // if notePath does not match, then the noteContext has been switched to another note in the meantime\n        if (noteContext.notePath === notePath) {\n            await this.noteSwitched();\n        }\n    }\n\n    async noteSwitched() {\n        await this.refresh();\n    }\n\n    async activeContextChangedEvent({noteContext}) {\n        this.noteContext = noteContext;\n\n        await this.activeContextChanged();\n    }\n\n    async activeContextChanged() {\n        await this.refresh();\n    }\n\n    // when note is both switched and activated, this should not produce a double refresh\n    async noteSwitchedAndActivatedEvent({noteContext, notePath}) {\n        this.noteContext = noteContext;\n\n        // if notePath does not match, then the noteContext has been switched to another note in the meantime\n        if (this.notePath === notePath) {\n            await this.refresh();\n        }\n    }\n\n    setNoteContextEvent({noteContext}) {\n        /** @var {NoteContext} */\n        this.noteContext = noteContext;\n    }\n\n    async noteTypeMimeChangedEvent({noteId}) {\n        if (this.isNote(noteId)) {\n            await this.refresh();\n        }\n    }\n\n    async frocaReloadedEvent() {\n        await this.refresh();\n    }\n}\n\nexport default NoteContextAwareWidget;\n","import NoteContextAwareWidget from \"./note_context_aware_widget.js\";\n\nconst WIDGET_TPL = `\n<div class=\"card widget\">\n    <div class=\"card-header\">\n        <div class=\"card-header-title\"></div>\n        <div class=\"card-header-buttons\"></div>\n    </div>\n\n    <div id=\"[to be set]\" class=\"body-wrapper\">\n        <div class=\"card-body\"></div>\n    </div>\n</div>`;\n\n/**\n * This widget manages rendering panels in the right-hand pane.\n * @extends {NoteContextAwareWidget}\n */\nclass RightPanelWidget extends NoteContextAwareWidget {\n    /** Title to show in the panel. */\n    get widgetTitle() { return \"Untitled widget\"; }\n\n    get widgetButtons() { return []; }\n\n    get help() { return {}; }\n\n    constructor() {\n        super();\n\n        this.child(...this.widgetButtons);\n    }\n\n    /**\n     * Do not override this method unless you know what you're doing.\n     * Do not override this method unless you know what you're doing.\n     */\n    doRender() {\n        this.$widget = $(WIDGET_TPL);\n        this.contentSized();\n        this.$widget.find('[data-target]').attr('data-target', `#${this.componentId}`);\n\n        this.$bodyWrapper = this.$widget.find('.body-wrapper');\n        this.$bodyWrapper.attr('id', this.componentId); // for toggle to work we need id\n\n        this.$body = this.$bodyWrapper.find('.card-body');\n\n        this.$title = this.$widget.find('.card-header .card-header-title');\n        this.$title.text(this.widgetTitle);\n\n        this.$buttons = this.$widget.find('.card-header .card-header-buttons');\n        this.$buttons.empty();\n\n        for (const buttonWidget of this.children) {\n            this.$buttons.append(buttonWidget.render());\n        }\n\n        this.initialized = this.doRenderBody();\n    }\n\n    /**\n     * Method used for rendering the body of the widget (via existing this.$body)\n     *\n     * Your class should override this method.\n     * @returns {Promise|undefined} if widget needs async operation to initialize, it can return a Promise\n     */\n    async doRenderBody() {}\n}\n\nexport default RightPanelWidget;\n"],"names":["RootCommandExecutor","editReadOnlyNoteCommand","noteContext","viewScope","readOnlyTemporarilyDisabled","async","sqlConsoleNote","noteId","activate","ntxId","searchString","ancestorNoteId","searchNote","froca","notePath","tree","this","searchNotesCommand","openNoteExternallyCommand","mime","openNoteCustomCommand","enterProtectedSessionCommand","leaveProtectedSessionCommand","hideLeftPaneCommand","options","showLeftPaneCommand","toggleLeftPaneCommand","showAndHoistSubtree","section","hoistedNoteId","subtreeNoteId","viewMode","toggleTrayCommand","utils","BrowserWindow","windows","getAllWindows","action","every","w","isVisible","window","firstTabCommand","secondTabCommand","thirdTabCommand","fourthTabCommand","fifthTabCommand","sixthTabCommand","seventhTabCommand","eigthTabCommand","ninthTabCommand","lastTabCommand","Number","POSITIVE_INFINITY","tabNumber","mainNoteContexts","tab","length","Entrypoints","constructor","super","jQuery","hotkeys","filterInputAcceptingElements","filterContentEditable","filterTextInputs","openDevToolsCommand","getCurrentWindow","toggleDevTools","inboxNote","note","server","content","type","isProtected","ws","isNewNote","noteToHoist","activeNoteContext","unhoist","setHoistedNoteId","copyWithoutFormattingCommand","toggleFullscreenCommand","win","isFullScreenable","setFullScreen","isFullScreen","reloadFrontendAppCommand","logoutCommand","$logoutForm","$","append","glob","csrfToken","trigger","backInNoteHistoryCommand","webContents","getCurrentWebContents","activeIndex","parseInt","getActiveIndex","goToIndex","history","back","forwardInNoteHistoryCommand","forward","extraWindowHash","ipcRenderer","send","url","location","protocol","host","pathname","open","openInWindowCommand","endsWith","bundle","resp","success","toast","error","results","hideAllPopups","autocomplete","noteSwitchedEvent","activeContextChangedEvent","NoteContext","mainNtxId","generateNtxId","resetViewScope","static","setEmpty","parentNoteId","triggerEvent","isEmpty","inputNotePath","opts","triggerSwitchEvent","undefined","resolvedNotePath","getResolvedNotePath","saveToRecentNotes","setHoistedNoteIfNeeded","triggerCommand","screen","startsWith","isLabelTruthy","isLaunchBarConfig","isOptions","getSubContexts","nc","isMainContext","getMainContext","e","setTimeout","logError","notePathArray","split","isActive","getPojoState","active","noteIdToHoist","includes","setNote","blob","getBlob","sizeLimit","contentLength","loadResults","isNoteReloaded","getEntityRow","isDeleted","hasNoteList","hasChildren","callback","timeout","Promise","resolve","promise","race","res","title","attachmentId","attachment","getAttachmentById","Mutex","current","lock","resolveFun","subPromise","newPromise","then","cb","unlock","TabManager","children","mutex","activeNtxId","recentlyClosedTabs","tabsUpdate","openNoteContexts","noteContexts","map","filter","t","JSON","stringify","noteContextsToOpen","flatMap","filteredNoteContexts","openTab","parsedFromUrl","href","push","find","allowUpdateWithoutChange","openContextWithNote","message","stack","openEmptyTab","setCurrentNavigationStateToHash","scheduleUpdate","calculatedHash","calculateHash","hash","pushState","getActiveContext","updateDocumentTitle","getNoteContexts","getMainNoteContexts","getNoteContextById","Error","getActiveMainContext","getActiveContextNotePath","activeContext","getActiveContextNote","getActiveContextNoteId","activeNote","getActiveContextNoteType","getActiveContextNoteMime","activateNoteContext","existingNoteContext","child","targetNoteId","runExclusively","noteContextToRemove","noteContextsToRemove","ntxIdsToRemove","ntxIds","openAndActivateEmptyTab","findIndex","activatePreviousTabCommand","activateNextTabCommand","siblings","idx","contextToActivate","removeNoteContexts","position","addToRecentlyClosedTabs","contexts","tabReorderEvent","ntxIdsInOrder","order","i","sort","a","b","noteContextReorderEvent","oldMainNtxId","newMainNtxId","Object","fromEntries","v","forEach","c","activeMainNtxId","oldIdx","newActiveNtxId","removeNoteContext","beforeUnloadEvent","updateNowIfNecessary","openNewTabCommand","ntxIdToRemove","closeLastEmptyTab","lastClosedTab","pop","ntxsInOrder","slice","mainNtx","tabPosition","afterNtxId","noteContextToActivate","hoistedNoteChangedEvent","titleFragments","getNavigationTitle","Boolean","document","join","MobileScreenSwitcherExecutor","setActiveScreenCommand","activeScreen","MainTreeExecutors","selectedOrActiveNoteIds","getSelectedOrActiveNodes","node","data","noteIds","selectedOrActiveBranchIds","branchId","branchIds","saveSelection","getActiveNode","parentNotePath","getParent","target","targetBranchId","ShortcutComponent","shortcutAttributes","attr","bindNoteShortcutHandler","labelOrRow","namespace","attributeId","value","getAttributeRows","name","AppContext","isMainWindow","components","beforeUnloadListeners","setLayout","layout","initComponents","renderWidgets","tabManager","loadTabs","component","zoom","rootWidget","getRootWidget","$renderedWidget","render","on","hasClass","commandName","closest","prop","$el","handleEvent","executor","fun","callMethod","console","debug","getComponentByEl","el","addBeforeUnloadListener","obj","WeakRef","appContext","allSaved","wr","deref","weakRef","log","componentId","switchToNoteContext","Component","sanitizedClassName","initialized","replace","setParent","parent","callMethodPromise","childrenPromise","handleEventInChildren","all","promises","ret","startTime","Date","now","call","took","isDev","ZoomComponent","setZoomFactor","addEventListener","event","ctrlKey","setZoomFactorAndSave","getCurrentZoom","deltaY","zoomFactor","parseFloat","webFrame","Math","round","getZoomFactor","zoomOutEvent","zoomInEvent","zoomResetEvent","setZoomFactorAndSaveEvent","row","update","ownerId","role","dateModified","utcDateModified","utcDateScheduledForErasureSince","attachments","getNote","notes","isInheritable","isAutoLink","toString","isDefinition","getDefinition","isDefinitionFor","dto","assign","notePosition","prefix","isExpanded","fromSearchNote","getNoteFromCache","isTopLevel","pojo","registeredClasses","Set","color","trim","normalizedColorName","className","has","add","LABEL","RELATION","NOTE_TYPE_ICONS","attributes","targetRelations","parents","parentToBranch","childToBranch","blobId","addParent","sortParents","addChild","childNoteId","sortChildren","branchIdPos","values","getBranch","isJson","getContent","parse","getParentBranchIds","getBranchIds","getParentBranches","getBranches","getChildBranches","getParentNoteIds","getParentNotes","getNotesFromCache","aNoteId","bNoteId","aBranchId","aNote","isArchived","isHiddenCompletely","hasAttribute","getChildNoteIds","getNotes","getAttachmentsForNote","getAttachments","att","isEligibleForConversionToAttachment","isContentAvailable","getTargetRelations","relation","parentNote","referencingNote","getOwnedAttributes","attrs","__filterAttrs","getAttributes","__getCachedAttributes","path","newPath","attrArrs","__getInheritableAttributes","templateAttr","flat","templateNote","addedAttributeIds","isRoot","getAllNotePaths","parentNotes","notePaths","getSortedNotePathRecords","isHoistedRoot","isInHoistedSubTree","some","isSearch","isHidden","getBestNotePath","getBestNotePathString","__validateTypeName","firstLetter","charAt","getOwnedLabels","getLabels","getIcon","iconClassLabels","workspaceIconClass","getWorkspaceIconClass","isFolder","getColorClass","getLabelValue","getFilteredChildBranches","childBranches","getOwnedRelations","getRelations","hasOwnedAttribute","getOwnedAttribute","getAttribute","getOwnedAttributeValue","getAttributeValue","hasOwnedLabel","hasLabel","label","getLabel","hasOwnedRelation","hasRelation","getOwnedLabel","getOwnedRelation","getRelation","getOwnedLabelValue","getOwnedRelationValue","getRelationValue","targets","getRelationTargets","relations","getNotesToInheritAttributesFrom","rel","getPromotedDefinitionAttributes","promotedAttrs","def","isPromoted","hasAncestor","followTemplates","visitedNoteIds","isInHiddenSubtree","invalidateAttributeCache","tr","getCssClass","l","labels","getWorkspaceTabBackgroundColor","isJavaScript","isHtml","getScriptEnv","env","bundleService","default","getAndExecuteBundle","isShared","$widget","dateContextMenuOpenedMs","hide","empty","addItems","items","positionMenu","clientHeight","documentElement","clientWidth","contextMenuHeight","outerHeight","contextMenuWidth","outerWidth","top","left","y","orientation","x","css","display","addClass","$parent","item","$icon","uiIcon","$link","$item","stopPropagation","which","handler","selectMenuItemHandler","enabled","$subMenu","openContextMenu","pageX","pageY","command","subContexts","renderAttribute","attribute","renderIsInheritable","$attr","createTextNode","val","test","class","text","createLink","renderAttributes","$container","html","HIDDEN_ATTRIBUTES","renderNormalAttributes","promotedDefinitionAttributes","promAttr","$renderedAttributes","count","originEntity","script","params","executeBundle","apiContext","allNoteIds","eval","executeStartupBundles","isMobile","scriptBundles","WidgetsByParent","byParent","widget","parentWidget","get","parentName","prototype","getWidgetBundlesByParent","widgetsByParent","idCounter","getRenderedContent","entity","tooltip","getRenderingType","$renderedContent","childNoteIds","childNotes","childNote","showTooltip","showNoteIcon","renderChildrenList","renderMathInElement","trust","getNoteIdFromLink","referenceLinks","noteIdsToPrefetch","renderText","renderCode","encodedTitle","encodeURIComponent","random","$img","imageHasZoom","WZoom","create","maxScale","speed","zoomOnClick","renderImage","entityType","entityId","$content","$pdfPreview","$audioPreview","$videoPreview","$downloadButton","$openButton","toggle","renderFile","mermaidTheme","getComputedStyle","getPropertyValue","mermaid","mermaidAPI","initialize","startOnLoad","theme","securityLevel","svg","$error","renderMermaid","ctx","$button","getDayNote","date","getInboxNote","dayjs","format","getTodayNote","getWeekNote","getMonthNote","month","getYearNote","year","createSqlConsole","createSearchNote","info","confirm","confirmed","confirmDeleteNoteBoxWithNote","prompt","props","FBlob","getJsonContent","getJsonContentSafely","initializedPromise","loadInitialTree","branches","blobPromises","addResp","subTreeNoteId","noteRows","branchRows","attributeRows","noteIdsToSort","noteRow","p","branch","branchRow","attributeRow","targetNote","Array","from","searchResultNoteIds","highlightedTokens","isArray","resultNoteId","index","searchResultsLoaded","silentNotFoundError","trace","missingNoteIds","reloadNotes","attachmentRows","logInfo","processAttachmentRows","attachmentRow","key","catch","getHoistedNoteId","isHoistedNode","isTopLevelNode","checkNoteAccess","requestedNote","hoistedNote","isHoistedInHiddenSubtree","keyboardActionRepo","keyboardActionsLoaded","actions","actionName","effectiveShortcuts","shortcut","getActionsForScope","scope","getAction","silent","updateDisplayedShortcuts","each","keyboardActions","shortcuts","newTitle","setupActionsForElement","getActions","loadedScriptPromises","requireScript","assetPath","ajax","dataType","cache","requireCss","prependAssetPath","querySelectorAll","requireLibrary","library","cssUrl","js","scriptUrl","CKEDITOR","CODE_MIRROR","ESLINT","RELATION_MAP","PRINT_THIS","CALENDAR_WIDGET","KATEX","WHEEL_ZOOM","FORCE_GRAPH","MERMAID","EXCALIDRAW","MARKJS","getLinkIcon","icon","paramStr","pair","keys","parseNavigationStateFromUrl","hashIdx","indexOf","substr","paramString","match","decodeURIComponent","warn","goToLink","evt","goToLinkExt","hrefLink","preventDefault","isLeftClick","isMiddleClick","openInNewTab","leftClick","middleClick","withinEditLink","outsideOfCKEditor","toLowerCase","shell","openPath","getReferenceLinkTitle","address","getNotePathFromUrl","notePathMatch","exec","showNotePath","referenceLink","autoConvertToImage","linkTitle","$noteLink","resolvedNotePathSegments","loadReferenceLinkTitle","tagName","outerHTML","prepend","getReferenceLinkTitleSync","invalidate","createNote","focus","selectedHtml","dom","parseHTML","parseSelectedHtml","textEditor","getSelectedHtml","templateNoteId","removeSelection","chooseNoteType","createNoteWithTypePrompt","noteType","duplicateSubtree","origNote","mouseEnterHandler","linkId","floor","is","renderTooltip","tooltipClass","container","placement","boundary","template","sanitize","customClass","checkTooltip","bestNotePath","setupGlobalTooltip","remove","setupElementTooltip","checkType","getFileUrl","getUrlForDownload","download","downloadURL","openCustom","filePath","tmpFilePath","platform","process","terminals","openFileWithTerminal","terminal","stdout","stderr","searchTerminal","err","URL","hostname","port","getHost","openExternally","electron","canOpenInBrowser","getOpenFileUrl","downloadFileNote","downloadRevision","revisionId","downloadAttachment","openNoteExternally","openAttachmentExternally","openNoteCustom","openAttachmentCustom","load","arr","getNames","getJson","getInt","getFloat","set","payload","save","tokens","defObj","token","labelType","multiplicity","chunks","numberPrecision","promotedAlias","inverseRelation","protectedSessionDeferred","enterProtectedSession","dfd","Deferred","makeToast","protectingLabel","id","taskId","protect","reloadData","taskType","progressCount","closeAfter","protectNote","includingSubtree","leaveProtectedSession","setupProtectedSession","password","isProtectedSessionAvailable","touchProtectedSession","enableProtectedSession","resetProtectedSession","touchProtectedSessionIfNecessary","renderNoteIds","renderNoteId","$scriptContainer","startNote","currentNote","prepareParams","RightPanelWidget","NoteContextAwareWidget","BasicWidget","activateNote","activateNewNote","openTabWithNote","openSplitWithNote","addButtonToToolbar","reqBody","__runOnBackendInner","func","transactional","startNoteId","currentNoteId","originEntityName","originEntityId","executionResult","runOnBackend","runAsyncOnBackendWithManualTransactionHandling","searchForNotes","search","searchForNote","getInstanceName","instanceName","formatDateISO","parseDate","showMessage","showError","showInfoDialog","dialog","showConfirmDialog","showPromptDialog","createNoteLink","addTextToActiveContextEditor","getActiveContextTextEditor","getTextEditor","getActiveContextCodeEditor","getCodeEditor","getActiveNoteDetailWidget","protectSubTree","bindGlobalShortcut","waitUntilSynced","refreshIncludedNote","includedNoteId","randomString","formatSize","formatNoteSize","logMessages","logSpacedUpdates","messages","modules","allNotes","apis","require","moduleNoteIds","moduleName","candidates","exports","searchForNoteIds","ValidationError","getHeaders","headers","allHeaders","headerName","cookie","idToRequestMap","maxKnownEntityChangeId","method","ipc","requestId","reject","silentNotFound","baseApiUrl","rej","body","textStatus","jqXhr","respHeaders","getAllResponseHeaders","line","parts","header","shift","status","reportError","responseText","contentType","maxEntityChangeIdStr","max","handleSuccessfulResponse","arg","statusCode","response","toastService","requestUrl","showErrorTitleAndMessage","throwError","getWithSilentNotFound","post","put","patch","upload","fileToUpload","formData","FormData","processData","getMaxKnownEntityChangeId","SpacedUpdate","updater","updateInterval","lastUpdated","changed","changeForbidden","triggerUpdate","isAllSavedAndTriggerUpdate","$toast","delay","autohide","showAndLogError","showPersistent","closePersistent","resolveNotePathToSegments","logErrors","reverse","effectivePathSegments","pathToRoot","getNoteIdFromUrl","urlOrNotePath","segments","getNoteIdAndParentIdFromUrl","getNoteTitle","getNotePathTitleComponents","titleComponents","show","resolveNotePath","runPath","getParentProtectedStatus","getNotePath","getBranchIdFromUrl","getNotePathTitle","getNoteTitleWithPathAsSuffix","$titleWithPath","isNotePathInHiddenSubtree","LoadResults","entityChanges","entities","entityName","noteIdToComponentId","componentIdToNoteIds","noteReorderings","revisionRows","contentNoteIdToComponentId","optionNames","addNote","addBranch","getBranchRows","addNoteReordering","getNoteReorderings","addAttribute","addRevision","hasRevisionForNote","getNoteIds","componentIds","sId","addNoteContent","isNoteContentReloaded","addOption","isOptionReloaded","getOptionNames","addAttachmentRow","getAttachmentRows","hasAttributeRelatedChanges","isEmptyForTree","processNoteChange","ec","isErased","processBranchChange","processNoteReordering","parentNoteIdsToSort","positions","processAttributeChange","sourceNote","processAttachment","processEntityChanges","messageHandlers","lastPingTs","lastAcceptedEntityChangeId","maxEntityChangeIdAtLoad","lastAcceptedEntityChangeSyncId","maxEntityChangeSyncIdAtLoad","lastProcessedEntityChangeId","frontendUpdateDataQueue","readyState","consumeQueuePromise","processedEntityChangeIds","handleMessage","messageHandler","filteredRows","logRows","entityChange","isSynced","sendPing","allEntityChanges","nonProcessedEntityChanges","entityChangeIdReachedListeners","desiredEntityChangeId","resolvePromise","start","consumeFrontendUpdateData","executeFrontendUpdate","connectWebSocket","loc","webSocketUri","WebSocket","onopen","onmessage","OPEN","lastEntityChangeId","CLOSED","CLOSING","setInterval","subscribeToMessages","waitForMaxKnownEntityChangeId","getMaxKnownEntityChangeSyncId","style","classes","childPositionCounter","contentSized","collapsible","filling","cssBlock","block","cssEl","doRender","isEnabled","toggleInt","toggleClass","isHiddenInt","toggleExt","isHiddenExt","canBeShown","getPosition","getClosestNtxId","cleanup","isNoteContext","isActiveNoteContext","isNote","refreshWithNote","noteSwitched","refresh","activeContextChanged","setNoteContextEvent","widgetTitle","widgetButtons","help","$bodyWrapper","$body","$title","$buttons","buttonWidget","doRenderBody"],"sourceRoot":""}